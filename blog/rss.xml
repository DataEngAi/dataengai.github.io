<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>DataSQRL Blog</title>
        <link>https://www.datasqrl.com/blog</link>
        <description>DataSQRL Blog</description>
        <lastBuildDate>Thu, 11 May 2023 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[DataSQRL 0.1: A SQRL is born]]></title>
            <link>https://www.datasqrl.com/blog/datasqrl-01-release</link>
            <guid>https://www.datasqrl.com/blog/datasqrl-01-release</guid>
            <pubDate>Thu, 11 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[" width="40%"/>]]></description>
            <content:encoded><![CDATA[<img loading="lazy" src="/img/blog/datasqrlv0.1.jpeg" alt="DataSQRL v0.1 release: A SQRL is Born >" width="40%" class="img_ev3q"><p>After two long years of research, development, and teamwork, we're excited to announce DataSQRL 0.1! <a href="/">DataSQRL</a> is a tool for building APIs from your data streams and datasets by defining your use case in a <a href="/docs/getting-started/concepts/sqrl/">SQL dialect</a>.</p><p>This is our first “official” release of DataSQRL after many months of testing and bug-fixing. <br>
Check out the <a href="https://github.com/DataSQRL/sqrl/releases/tag/v0.1.0" target="_blank" rel="noopener noreferrer">release notes</a> on GitHub for a rundown of all the features.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="our-vision">Our Vision<a href="#our-vision" class="hash-link" aria-label="Direct link to Our Vision" title="Direct link to Our Vision">​</a></h2><p>Every time we wanted to build a new use case for our application and expose a data API, we found ourselves getting distracted. Distracted by all the orchestration, the technology choices, all the micro-decisions, and the 'plumbing' that goes into the modern data layer. So we up-leveled the abstraction and kept it simple. We <a href="/docs/getting-started/concepts/why-datasqrl/">designed DataSQRL</a> to handle those nitty-gritty details, so you could stay focused on what truly mattered - building cool things.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="simplicity-through-sql">Simplicity Through SQL<a href="#simplicity-through-sql" class="hash-link" aria-label="Direct link to Simplicity Through SQL" title="Direct link to Simplicity Through SQL">​</a></h2><p>We've kept <a href="/docs/getting-started/concepts/sqrl/">DataSQRL true to SQL</a>, so it feels familiar and easy to use. We enhanced and modernized the language while maintaining the simplicity of SQL queries. No more wrestling with subqueries, window functions, or repetitive joins - just straightforward SQL.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="flexible-apis">Flexible APIs<a href="#flexible-apis" class="hash-link" aria-label="Direct link to Flexible APIs" title="Direct link to Flexible APIs">​</a></h2><p>One size doesn't fit all when it comes to APIs. We made DataSQRL non-opinionated, giving you the freedom to use your <a href="/docs/reference/api/graphql/design/">preferred GraphQL schema</a> and customize your query patterns with SQRL scripts.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="our-road-ahead">Our Road Ahead<a href="#our-road-ahead" class="hash-link" aria-label="Direct link to Our Road Ahead" title="Direct link to Our Road Ahead">​</a></h2><p>We're seeking <a href="/community/">your feedback</a> to help shape the future of DataSQRL. Our current architecture supports a range of platforms, and we're working on making it more extensible and useful. Your input is invaluable as we continue to refine and expand DataSQRL's capabilities.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><p>The only danger now is that your boss might think he can start coding again. <a href="/community/">Join us</a> as we explore the story behind DataSQRL, its impact on the world of data processing, and the exciting possibilities it holds for the future.</p>]]></content:encoded>
            <category>DataSQRL</category>
            <category>release</category>
        </item>
        <item>
            <title><![CDATA[The Two Core Data Problems for Developers: Transactional & Reactive]]></title>
            <link>https://www.datasqrl.com/blog/types-of-data-problems-transactional-reactive</link>
            <guid>https://www.datasqrl.com/blog/types-of-data-problems-transactional-reactive</guid>
            <pubDate>Mon, 01 May 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[Introduction]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a href="#introduction" class="hash-link" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a></h2><p>Every developer, whether you build applications or backend services, encounters two distinct types of data problems: transactional and reactive. The need to store and retrieve application state is a quintessential example of a transactional data problem. Conversely, when you're processing events or consuming data from external sources, you're confronted with a reactive data problem. </p><p>Knowing which problem you're up against is crucial to selecting the right tools from your developer's kit. It’s important to determine what type of data problem you are dealing with to choose the right tools and approaches for implementing a solution. After all, using a hammer for a screw job can leave you with more than a few cracks to mend.</p><p>In this post, we'll guide you on how to differentiate between transactional and reactive data problems and pick the right tools and strategies to solve each of them.</p><p>Table of Contents:</p><ul><li><a href="#pitfall">The Pitfall of Misinterpreting Reactive Problems as Transactional</a></li><li><a href="#what-tx">What are Transactional Data Problems?</a></li><li><a href="#solve-tx">Solving Transactional Data Problems</a></li><li><a href="#what-rx">What are Reactive Data Problems?</a></li><li><a href="#solve-rx">Solving Reactive Data Problems</a></li><li><a href="#conclusion">Conclusion</a></li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="pitfall">The Pitfall of Misinterpreting Reactive Problems as Transactional<a href="#pitfall" class="hash-link" aria-label="Direct link to The Pitfall of Misinterpreting Reactive Problems as Transactional" title="Direct link to The Pitfall of Misinterpreting Reactive Problems as Transactional">​</a></h2><img loading="lazy" src="/img/blog/arrived_logo.png" alt="Arrived Logo >" width="30%" class="img_ev3q"><p>Let's kick things off with an anecdote from my career. An episode where I mistakenly treated a reactive data problem as a transactional one, resulting in a full-blown application meltdown. Definitely not a shining moment of my career.</p><p>Flashback to 2011, I was the backend developer for a sprouting startup named "Arrived". Our vision was to connect people in the real world by using their phone’s location data. That was the time when smartphones started to support geo-fencing and folks thought Foursquare was going to become the next Facebook. Fun times.</p><p>We built an iPhone app that allowed users to establish geo-fences and automatically check-in, alerting their connections upon entry. For a brief overview of the app, check out <a href="https://techcrunch.com/2011/11/10/i-am-a-passenger-and-i-arrive-and-arrived/" target="_blank" rel="noopener noreferrer">this brutally hilarious review</a> from our TechCrunch Disrupt final presentation. While it was soul-crushing at the time, it's quite a fun read in retrospect.</p><p>I implemented the backend of the application as a Java web service, complete with a REST API for user creation, user connection management, and alert dispatch. The API primarily dealt with storing and retrieving user states, connections, geo-fences, and more. These are typical transactional data problems: how to maintain your application state in a durable, reliable, and consistent way. To tackle this, I used MySQL as the database and an object-relational mapping library to translate my Java objects to database rows.</p><p>All was sailing smoothly until we decided to implement a social feature to enhance the onboarding experience and boost the app's "virality". This feature uploaded a user’s phone contacts to check if any of their contacts were already using Arrived, suggesting them as potential connections.</p><img loading="lazy" src="/img/blog/arrived_app.png" alt="Arrived Mobile App Screenshot >|" width="30%" class="img_ev3q"><p>That looked like another transactional data problem to me. Or rather, I was oblivious to the existence of other types of data problems and defaulted to it being transactional.</p><p>Thus, I embarked on a path that would eventually lead to disaster. The "upload contacts" API call I set up did the following: </p><ul><li>stored all contact entries in the database, </li><li>ran a for-loop to match any entry hashes already in the database, </li><li>added a "potential connection" record to another table in case of a match.</li></ul><p>To my credit, the feature worked as intended. I even had a passing test case. But once we launched the feature in production, our database froze.</p><p>As it turned out, some users had an expansive social circle with over a thousand contacts. Running a transaction that writes thousands of records and fires off as many read queries on your primary operational database, which also services all your API requests, is a recipe for disaster. Needless to say, the database was not a fan of this idea and promptly crashed.</p><p>But my mistake was not a coding error. The code worked fine. The mistake was failing to realize that the “contacts matching feature” was a reactive data problem, not a transactional one. We were ingesting data from an external source - a user’s contact list - and reacting to it by comparing matches against our existing user base.</p><p>In the upcoming sections, we'll delve deeper into the differences between transactional and reactive data problems and how to solve them. We'll also revisit my reactive data problem and explore how a more informed approach could have saved me from a full-blown, hair-on-fire database crisis.</p><p>We will discuss how I could have solved my reactive data problem better and avoided a hair-on-fire database resurrection after we explore transactional and reactive data problems in more detail and how to distinguish between them.</p><p>As for "Arrived", we learned that our most active users were over-vigilant parents monitoring their children, which was not our target audience. Consequently, we had to close shop in less than two years.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-tx">What are Transactional Data Problems?<a href="#what-tx" class="hash-link" aria-label="Direct link to What are Transactional Data Problems?" title="Direct link to What are Transactional Data Problems?">​</a></h2><p>Transactional data problems arise when you need to store and retrieve data concurrently while maintaining consistency. Here, "concurrently" refers to the simultaneous reading and writing of data by multiple threads or users. The trick is to ensure that data remains consistent throughout this flurry of updates.</p><p>There are two forms of inconsistencies we need to avoid. The first relates to upholding application constraints. For instance, if a username is required to be unique, we cannot allow two user records with identical usernames. This would be inconsistent with our application's unique username constraint. We may have several such constraints, like "account balances can't be negative," or "each product id in the orders table must correspond to an existing row in the product table."</p><p>The second inconsistency type relates to multiple updates triggered by a single request. We want to dodge situations where only some updates are stored. It's an all-or-nothing game - we either want all updates to be stored or none at all. For example, a request to transfer $100 from account A to account B requires updating both account balances. If only account A's balance is updated while account B's update fails, we've got a magical disappearing act of money.</p><p>Ensuring data consistency while managing concurrent user updates can be quite a challenge. You might encounter scenarios where two users try to register with the same username simultaneously or two users attempt to withdraw from the same account, causing the balance to plummet below zero. Situations like these are why data storage and retrieval often turn into a "problem" for developers.</p><p>Transactional data problems typically surface when storing state for applications that multiple users can access concurrently, or when building CRUD APIs.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solve-tx">Solving Transactional Data Problems<a href="#solve-tx" class="hash-link" aria-label="Direct link to Solving Transactional Data Problems" title="Direct link to Solving Transactional Data Problems">​</a></h2><p>The panacea for transactional data problems? Databases. Developers harness the power of databases to efficiently handle the concurrency and consistency issues associated with transactional data problems.</p><p>However, databases aren't one-size-fits-all. They differ in the types of consistency and concurrency guarantees they offer. If you're using any of the popular relational databases (like Postgres, MySQL, SqlServer, Oracle, and Aurora), breathe easy. They're likely equipped with all the support you need. For other databases, it's worth checking what exactly they support to avoid surprises down the line.</p><p>Alongside the choice of database, you'll also want to equip yourself with a tool that simplifies interactions with the database from your programming language. Wrestling with databases directly can be cumbersome, requiring the use of drivers, query string writing, and data mapping. If you're working in an object-oriented programming language, an object-relational mapping layer (or ORM for short) can be your best friend, translating seamlessly between your application and the database. If not, seek out an SDK or database abstraction layer that's compatible with your chosen database.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-rx">What are Reactive Data Problems?<a href="#what-rx" class="hash-link" aria-label="Direct link to What are Reactive Data Problems?" title="Direct link to What are Reactive Data Problems?">​</a></h2><p>You have a Reactive data problem when your data source is outside your application or service's control, and you're required to respond to the data quickly. Let’s break this down.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="unconstrained-data">Unconstrained Data<a href="#unconstrained-data" class="hash-link" aria-label="Direct link to Unconstrained Data" title="Direct link to Unconstrained Data">​</a></h3><p>When the data originates from an external source or isn't subject to any application constraints, your application does not control the data source. External data sources could include other systems like logs, message queues, files, external databases, or applications. Here, the data pre-exists independently of your control. For instance, a user's contact list is an external data source.</p><p>Moreover, data could be uncontrolled even within your application, provided it's free of any constraints. This includes events that occur organically within your application, such as a user clicking a button or visiting a webpage. These events aren't within your direct control - they just happen.</p><p>This is a stark contrast to transactional data problems, where the key challenge lies in maintaining data consistency amidst concurrent updates.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="the-need-for-speed">The Need for Speed<a href="#the-need-for-speed" class="hash-link" aria-label="Direct link to The Need for Speed" title="Direct link to The Need for Speed">​</a></h3><p>Another characteristic of reactive data problems is the necessity for swift data processing and result generation. This quick reaction is twofold: it must occur shortly after receiving the data, and it involves computational processing of that data.</p><p>Take the contacts matching feature in Arrived, for instance. The goal was to encourage users to establish connections during the signup process. Consequently, we had to compute the matches within a few seconds - before the user completed the signup and exited the app.</p><p>How swift does this reaction need to be to qualify as "quick"? It varies according to your use case. Customer-facing use cases typically demand reactions within seconds to minutes, tops. For use cases like fraud detection, system automation, or financial transactions, you may need to respond within milliseconds. If the results can wait for hours or even days, it wouldn't qualify as quick.</p><p>The "reaction" element primarily involves generating a response to incoming data, which could either serve back to the user or trigger an action. This could mean processing a user's shopping cart to suggest other products they might like, analyzing system metrics to detect potential overload, feeding user activity into a machine learning model for a personalized journey, or evaluating if a transaction request is fraudulent. In each instance, we take a piece of data, evaluate it within the application context, and produce a useful response.</p><p>In essence, reactive data problems call for quick, efficient responses to one or multiple data sources. The challenges arise from the need to carry out data-intensive computations rapidly, efficiently, and robustly.</p><p>Reactive data problems commonly crop up in use cases such as:</p><ul><li>Personalization or recommendation engines</li><li>User experience features</li><li>Metrics or time-series analysis</li><li>Machine learning features</li><li>Fraud detection</li><li>Cybersecurity and intrusion detection</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="solve-rx">How do you solve Reactive Data Problems?<a href="#solve-rx" class="hash-link" aria-label="Direct link to How do you solve Reactive Data Problems?" title="Direct link to How do you solve Reactive Data Problems?">​</a></h2><p>Let's circle back to the reactive data problem of the contacts matching feature. My initial solution involved splitting the transaction into several parts, moving some computation to a background thread, fine-tuning the database schema, and writing a hefty amount of SQL. This strategy was time-consuming, fragile, and a nightmare to maintain. A colleague shrugged it off with “I’ve no idea what’s happening here, but I guess it works…”</p><p>The problem? When all you have is a hammer, everything looks like a nail. So, I tried hammering that screw into the wall. As expected, it was neither pretty nor productive.</p><img loading="lazy" src="/img/blog/reactive_data_layer_arrived.svg" alt="A Reactive Data Layer Architecture >" width="40%" class="img_ev3q"><p>To solve reactive data problems more effectively, we need to reimagine our data layer architecture. Let’s give our database some company by introducing additional components that make it easier to process data reactively:</p><ul><li><strong>Queue</strong>: Introducing a persisted message queue (or log) into our architecture can ease asynchronous data processing. This robust, scalable tool allows you to write incoming data to the queue and process it when resources are available, significantly simplifying multi-step data processing.</li><li><strong>Stream Processor</strong>: This is a framework dedicated to managing consecutive data processing steps, from data ingestion (reading data off the queue or from external systems) to data transformation, to writing the results to the database. This framework handles all task scheduling and execution, allowing you to focus on the actual processing logic.</li><li><strong>Server</strong>: This component accepts incoming data, writes it to the queue, and serves the processed data from the database. Acting as the entry and exit point for the reactive data layer, the server brings everything together. You can integrate this functionality into an existing API server implementation or create a standalone server to isolate the reactive data use case into its own backend service.</li></ul><p>To improve the contact matching feature, we finally adopted a reactive data architecture as illustrated in the diagram above. Here's how the data flowed:</p><ol><li>The server received the submitted contacts and wrote the entire data blob to a persisted messaging queue.</li><li>Three asynchronous tasks ran in the processing framework:<ol><li><em>Splitter</em>: This task read an entire contacts list from the queue, divided it into chunks of a maximum of 50 contacts, and wrote the resulting chunks back to the queue under a different topic.</li><li><em>Storer</em>: This task read contact chunks from the queue and wrote the contact entries as individual records to the database.</li><li><em>Matcher</em>: This task read contact chunks, matched the contact entries against the user table, and wrote the found matches to the database.</li></ol></li><li>The database stored contact entries and contact matches in a separate logical database, isolated from the main operational database serving the CRUD API of the Arrived app.</li><li>The server responded to "recommended contacts" requests during the signup process by running a query against the database that combined all pre-computed matches for the user with matches from checking the user's phone number against previously stored contact entries.</li></ol><p>This solution was not only efficient and robust but also easier to maintain. Above all, it allowed us to concentrate on enhancing the feature instead of hacking around the database.</p><p>So, here's the key takeaway: instead of grappling with reactive data problems using a database alone, build a reactive data layer. It will save you considerable time and frustration.</p><p>If building a custom data layer seems intimidating, consider checking out DataSQRL. It's a tool that constructs reactive data layers for you. We've been developing DataSQRL to assist developers in resolving reactive data problems quickly and efficiently. We would love to hear your feedback!</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Direct link to Conclusion" title="Direct link to Conclusion">​</a></h2><table><thead><tr><th>Type of Data Problem</th><th>Transactional</th><th>Reactive</th></tr></thead><tbody><tr><td>Response time expectation</td><td>Milliseconds</td><td>Milliseconds to minutes</td></tr><tr><td>Main challenge</td><td>Consistency under concurrency</td><td>Quick Reactions</td></tr><tr><td>Source of Data</td><td>Maintained by application</td><td>External or events</td></tr><tr><td>Consistency Requirements</td><td>Data constraints &amp; atomicity</td><td>Synchronization in time</td></tr><tr><td><strong>Data Layer Solution</strong></td><td><strong>Database + ORM</strong></td><td><strong>Queue + Processor + Database + Server</strong></td></tr></tbody></table><p>Transactional data problems arise when your application requires concurrent storage and retrieval of consistent data. On the other hand, reactive data problems occur when your application needs to quickly respond to data from external sources or events. Recognizing the distinction between these two types of data issues is crucial to implementing the most effective solution.</p><p>For transactional data problems, a data layer comprising a database and an Object-Relational Mapping (ORM) tool is often the best solution. On the contrary, reactive data problems are more efficiently addressed with a data layer that includes a queue, stream processor, database, and server. Understanding these distinctions and applying the appropriate solutions can significantly improve the efficiency and robustness of your data layer.</p>]]></content:encoded>
            <category>data</category>
        </item>
        <item>
            <title><![CDATA[Hello, World!]]></title>
            <link>https://www.datasqrl.com/blog/welcome</link>
            <guid>https://www.datasqrl.com/blog/welcome</guid>
            <pubDate>Thu, 26 Jan 2023 00:00:00 GMT</pubDate>
            <description><![CDATA[" width="40%"/>]]></description>
            <content:encoded><![CDATA[<img loading="lazy" src="/img/generic/undraw_launch.svg" alt="Launching DataSQRL >" width="40%" class="img_ev3q"><p>We are excited to launch <a href="/about/">DataSQRL</a> with the mission to help developers and organizations build with data.</p><p>Collectively, we have spent decades building or helping others build data services. We have seen many struggles, failures, and piles of money being thrown out the window and figured that there must be a better way. We started DataSQRL to find it.</p><p>We believe that the technologies used to build data services are too complex and that the engineering processes used to build them are broken. Here is how we plan to fix these issues.</p><p>We developed <a href="/">DataSQRL</a> which  compiles a developer-friendly version of SQL - called <a href="/docs/getting-started/concepts/sqrl/">SQRL</a> - into a fully integrated and optimized data pipeline and API server. It takes care of all the laborious plumbing, data massaging, and stitching together of technologies that makes building data services so harrowing. Check out <a href="/docs/getting-started/quickstart/">this short tutorial</a> to see how it works - it only takes a few minutes to build an end-to-end data service.</p><p>In addition, we are refining a value-focused process for implementing data services that we have developed over the years while working with development teams and organizations. The basic idea is to apply the same software engineering principles that have proven to be successful to implementing data services. That means you don't need a dedicated team of specialists to implement data services and can keep your customers and stakeholders in the feedback loop. <a href="/docs/process/intro/">Click here</a> to learn more about our process.</p><p>That's our starting point for enabling developers to build successful data services quickly and efficiently. We think we got some good ideas, but have been building data technologies long enough to realize that there is a fine line between innovation and wishful thinking.<br>
We hope that you will join the <a href="/community/">DataSQRL community</a> to share your experience, insights, and opinions to help set us straight.</p><p>If you are trying to enable your organization to turn data into valuable data services, consider <a href="/services/">working with us</a> and <a href="/contact/">get in touch</a>.</p><p>We are excited to be on this journey and hope you will join us. Let's build with data together.</p>]]></content:encoded>
            <category>DataSQRL</category>
        </item>
    </channel>
</rss>