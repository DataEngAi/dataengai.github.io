<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://datasqrl.github.io/blog</id>
    <title>DataSQRL Blog</title>
    <updated>2023-03-02T17:21:50.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://datasqrl.github.io/blog"/>
    <subtitle>DataSQRL Blog</subtitle>
    <icon>https://datasqrl.github.io/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[ideas/optimizer]]></title>
        <id>https://datasqrl.github.io/blog/ideas/optimizer</id>
        <link href="https://datasqrl.github.io/blog/ideas/optimizer"/>
        <updated>2023-03-02T17:21:50.000Z</updated>
        <summary type="html"><![CDATA[You can control how DataSQRL executes your scripts by providing annotation hints.]]></summary>
        <content type="html"><![CDATA[<p>You can control how DataSQRL executes your scripts by providing annotation hints.</p><p>Before we talk about those hints, let's take a short detour to discuss how DataSQRL executes SQRL scripts. DataSQRL is a combination of a stream processing engine and a database. The stream processing engine ingests data from the connected sources, validates it, and updates the tables defined in the SQRL script that are affected by the new data record. Table records are eventually written to the database where they can be queried by the API to answer API requests.</p><p><em>(insert schematic diagram visualizing it)</em></p><p>When DataSQRL converts an SQRL script to an execution plan, the optimizer determines which tables and columns should be incrementally computed by the stream processing engine when new data arrives or computed upon request inside the database for each API query. This decision has important implications for the performance and cost of the data service.</p><p>For example, the column <code>Customers._recent_avg_protein</code> from our <code>customer360.sqrl</code> script would be very expensive to compute at query time when we request product recommendations from the API because it requires a multi-way <code>JOIN</code> starting from all orders that a customer placed in the last 6 month. If we computed this at query time, the database would have to fetch a lot of data which takes time and is costly. It is much cheaper to incrementally update this column value whenever the customer places a new order and store the result in the database so it is instantly available at query time. \
On the other hand, incrementally computing the <code>Customers.products_by_protein</code> table when data changes would be very expensive since the ordering changes anytime the <code>Customers._recent_avg_protein</code> changes with a new order for that customer. Since we only have a couple hundred product records that don't change very often, it is much more efficient to compute <code>Customers.products_by_protein</code> at query time.</p><p>DataSQRL collects statistics on the source data and analyzes your script to make the optimal decision on whether to incrementally compute a particular table and column or compute it at query time. However, sometimes the optimizer gets it wrong. When that happens, you can provide a hint to DataSQRL to dictate that decision to the optimizer.</p><div class="theme-admonition theme-admonition-caution alert alert--warning admonition_LlT9"><div class="admonitionHeading_tbUL"><span class="admonitionIcon_kALy"><svg viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg></span>caution</div><div class="admonitionContent_S0QG"><p>Please send us example SQRL scripts where the optimizer makes the wrong decision and produces suboptimal results. We are actively working on improving the optimizer and your input is super valuable to us.</p></div></div><div class="language-sqrl codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-sqrl codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">-- @optimizer(materialize=true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Customers._recent_avg_protein :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SELECT SUM(e.quantity * p.weight_in_gram * n.protein)/SUM(e.quantity * p.weight_in_gram)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        FROM @.purchases.items e JOIN e.product p JOIN p.nutrition n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        WHERE e.parent.date &gt; now() - INTERVAL 6 MONTH;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- @api(paginate=true)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">-- @optimizer(materialize=false)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Customers.products_by_protein :=</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        SELECT p.id AS productid, ABS(p.nutrition.protein - @._recent_avg_protein) AS protein_difference FROM Products p</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ORDER BY protein_difference ASC LIMIT 20;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Customers.products_by_protein.product := JOIN Products ON Products.id = _productid LIMIT 1;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>With the <code>@optimizer</code> annotation we can pass hints to the optimizer. The boolean flag <code>materialize</code> tells the optimizer whether to incrementally update a table with changing data - i.e. to materialize a table as database folks would say - or to compute the table results at query time with each API request.</p><p>Learn more about the <a href="/docs/reference/operations/optimizer">DataSQRL optimizer</a> and how to provide hints to control the execution plan that it generates for your SQRL script. You can also learn more about the <a href="/docs/dev/architecture">architecture of DataSQRL</a> to dive deep into the internals of the system.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[introducing-sqrl]]></title>
        <id>https://datasqrl.github.io/blog/2023/02/02/introducing-sqrl</id>
        <link href="https://datasqrl.github.io/blog/2023/02/02/introducing-sqrl"/>
        <updated>2023-02-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Data management and analysis are at the forefront of modern businesses and applications, with the need for effective and efficient data services growing rapidly. SQL, the widely used relational database language, has been the foundation of data management for decades, but it has its limitations in the realm of data services. This is where SQRL comes into play.]]></summary>
        <content type="html"><![CDATA[<p>Data management and analysis are at the forefront of modern businesses and applications, with the need for effective and efficient data services growing rapidly. SQL, the widely used relational database language, has been the foundation of data management for decades, but it has its limitations in the realm of data services. This is where SQRL comes into play.</p><p>SQRL, short for Structured Query and Reaction Language, is a declarative language built on top of SQL that is specifically designed for developing data services. It is a modern alternative to SQL that extends its capabilities, providing developers with a more concise, intuitive, and productive way to work with data.</p><p>SQRL scripts are written in a SQL-like syntax that is easy to understand, even for developers who are not familiar with SQL. The language is loosely-typed, meaning that the data types of columns and tables are inferred from the input data. This saves time and reduces the need for manual type and schema management. In addition, SQRL supports IMPORT statements to declare data dependencies, allowing developers to easily manage their data sources.</p><p>One of the key advantages of SQRL is its incremental table definition feature. This feature allows developers to incrementally build up the logic of their data service by defining tables and columns through a series of SQL-like statements. This structure makes it easier to read and write SQRL scripts, making development more intuitive and less complex.</p><p>SQRL also adds relationships to SQL, enabling developers to link tables together and explicitly label their relationships. This makes the data structure easier to understand, as the relationships between tables are explicitly defined. Additionally, relationships can be reused across scripts, saving time and making code more maintainable.</p><p>Another significant feature of SQRL is its focus on streaming data services. With the rise of real-time data processing, developers need tools that can handle streaming data effectively. SQRL provides the necessary features and performance to handle real-time data processing, making it ideal for developing data services that require low latency and high throughput.</p><p>In conclusion, SQRL is the future of data services. It extends the capabilities of SQL and makes data service development more intuitive, efficient, and productive. SQRL is ideal for developers who are looking to build streaming data services, but it also offers features that make it a valuable tool for any data service project. Whether you are a seasoned SQL developer or new to data management, SQRL is an excellent choice for building data services that meet your needs and provide value to your customers.</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQRL: SQL for Data Services]]></title>
        <id>https://datasqrl.github.io/blog/sql-for-developers</id>
        <link href="https://datasqrl.github.io/blog/sql-for-developers"/>
        <updated>2023-01-31T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[To make it easier for developers to build data services, we developed the SQRL language which gives SQL a facelift and adds some important features to make it developer friendly, productive, and fun. Here is why we need a modern, developer-focused version of SQL.]]></summary>
        <content type="html"><![CDATA[<p>To make it easier for developers to build data services, we developed the SQRL language which gives SQL a facelift and adds some important features to make it developer friendly, productive, and fun. Here is why we need a modern, developer-focused version of SQL.</p><p>SQL is the most popular query language and great for manipulating structured data. But SQL is not a great development language, and it's a bit ... well, old. It's a fantastic accomplishment for a 50+ year old language to be in wide-spread use today, but to keep up with the times a lot of features were bolted onto SQL that make it feel a bit frankensteinish today. Yes, we are looking at you SQL:2016.</p><p>Plus, most developers have a love-hate relationship with SQL because they primarily use it through ORMs or other abstraction layers. That level of indirection can make things unintuitive and embedding SQL as a string is just ugly. That's why ORMs have been called "the Vietnam of software engineering", and while an analogy with a major war seems a wee bit dramatic, it does capture developer feelings pretty accurately.</p><p>We believe that SQL is the best starting point if you are trying to build with data, but there are a few things missing to make it a productive choice for implementing data services.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="data-streams">Data Streams<a href="#data-streams" class="hash-link" aria-label="Direct link to Data Streams" title="Direct link to Data Streams">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="relationships">Relationships<a href="#relationships" class="hash-link" aria-label="Direct link to Relationships" title="Direct link to Relationships">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="nested-data">Nested Data<a href="#nested-data" class="hash-link" aria-label="Direct link to Nested Data" title="Direct link to Nested Data">​</a></h2><h2 class="anchor anchorWithStickyNavbar_LWe7" id="modularity">Modularity<a href="#modularity" class="hash-link" aria-label="Direct link to Modularity" title="Direct link to Modularity">​</a></h2><p>SQRL addresses these shortcomings in SQL while being fully compatible with SQL. Learn more about SQRL or follow a short tutorial to see how you can build a data service in minutes with SQRL.</p>]]></content>
        <author>
            <name>Matthias Broecheler</name>
            <uri>https://github.com/mbroecheler</uri>
        </author>
        <category label="SQL" term="SQL"/>
        <category label="SQRL" term="SQRL"/>
        <category label="database" term="database"/>
        <category label="developer" term="developer"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello, World!]]></title>
        <id>https://datasqrl.github.io/blog/welcome</id>
        <link href="https://datasqrl.github.io/blog/welcome"/>
        <updated>2023-01-26T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[We are excited to launch DataSQRL with the mission to help developers and organizations build with data.]]></summary>
        <content type="html"><![CDATA[<p>We are excited to launch <a href="/about">DataSQRL</a> with the mission to help developers and organizations build with data.</p><p>Collectively, we have spent decades building or helping others build data services. We have seen many struggles, failures, and piles of money being thrown out the window and figured that there must be a better way. We started DataSQRL to find it.</p><p>We believe that the technologies used to build data services are too complex and that the engineering processes used to build them are broken. Here is how we plan to fix these issues.</p><p>We developed <a href="/">DataSQRL</a> which  compiles an enhanced version of SQL - called SQRL - into a fully integrated and optimized data pipeline and API server. It takes care of all the laborious plumbing, data massaging, and stitching together of technologies that makes building data services so harrowing. Check out this short tutorial to see how it works - it only takes a few minutes to build an end-to-end data service.</p><p>In addition, we are refining a value-focused process for implementing data services that we have developed over the years while working with development teams and organizations. The basic idea is to apply the same software engineering principles that have proven to be successful to implementing data services. That means you don't need a dedicated team of specialists to implement data services and can keep your customers and stakeholders in the feedback loop. Click here to learn more about our process.</p><p>That's a good starting point for enabling developers to build successful data services quickly and efficiently. But we don't think we have all the answers.<br>
We hope that you will join the <a href="/community">DataSQRL community</a> to share your experience, insights, and opinions. <br>
If you are trying to enable your organization to turn data into valuable data services, consider <a href="/services">working with us</a> and <a href="/contact">get in touch</a>.</p><p>We are excited to be on this journey and hope you will join us. Let's build with data together.</p>]]></content>
        <author>
            <name>Matthias Broecheler</name>
            <uri>https://github.com/mbroecheler</uri>
        </author>
        <category label="DataSQRL" term="DataSQRL"/>
    </entry>
</feed>