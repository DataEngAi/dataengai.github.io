"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3726],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(a),h=r,m=d["".concat(l,".").concat(h)]||d[h]||p[h]||o;return a?n.createElement(m,i(i({ref:t},u),{},{components:a})):n.createElement(m,i({ref:t},u))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},7026:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var n=a(7462),r=(a(7294),a(3905));const o={slug:"types-of-data-problems-transactional-reactive",title:"The Two Core Data Problems for Developers: Transactional & Reactive",authors:["matthias"],tags:["data"]},i="The Two Core Data Problems for Developers: Transactional & Reactive",s={permalink:"/blog/types-of-data-problems-transactional-reactive",editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/blog/2023-05-01-two-types-of-data-problems-transactional-reactive.md",source:"@site/blog/2023-05-01-two-types-of-data-problems-transactional-reactive.md",title:"The Two Core Data Problems for Developers: Transactional & Reactive",description:"Introduction",date:"2023-05-01T00:00:00.000Z",formattedDate:"May 1, 2023",tags:[{label:"data",permalink:"/blog/tags/data"}],readingTime:12.825,hasTruncateMarker:!0,authors:[{name:"Matthias Broecheler",title:"CEO of DataSQRL",url:"https://github.com/mbroecheler",imageURL:"/img/headshots/matthias1.png",key:"matthias"}],frontMatter:{slug:"types-of-data-problems-transactional-reactive",title:"The Two Core Data Problems for Developers: Transactional & Reactive",authors:["matthias"],tags:["data"]},prevItem:{title:"DataSQRL 0.1: A SQRL is born",permalink:"/blog/datasqrl-01-release"},nextItem:{title:"Hello, World!",permalink:"/blog/welcome"}},l={authorsImageUrls:[void 0]},c=[{value:"Introduction",id:"introduction",level:2},{value:"The Pitfall of Misinterpreting Reactive Problems as Transactional",id:"pitfall",level:2},{value:"What are Transactional Data Problems?",id:"what-tx",level:2},{value:"Solving Transactional Data Problems",id:"solve-tx",level:2},{value:"What are Reactive Data Problems?",id:"what-rx",level:2},{value:"Unconstrained Data",id:"unconstrained-data",level:3},{value:"The Need for Speed",id:"the-need-for-speed",level:3},{value:"How do you solve Reactive Data Problems?",id:"solve-rx",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:c},d="wrapper";function p(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Every developer, whether you build applications or backend services, encounters two distinct types of data problems: transactional and reactive. The need to store and retrieve application state is a quintessential example of a transactional data problem. Conversely, when you're processing events or consuming data from external sources, you're confronted with a reactive data problem. "),(0,r.kt)("p",null,"Knowing which problem you're up against is crucial to selecting the right tools from your developer's kit. It\u2019s important to determine what type of data problem you are dealing with to choose the right tools and approaches for implementing a solution. After all, using a hammer for a screw job can leave you with more than a few cracks to mend."),(0,r.kt)("p",null,"In this post, we'll guide you on how to differentiate between transactional and reactive data problems and pick the right tools and strategies to solve each of them."),(0,r.kt)("p",null,"Table of Contents:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#pitfall"},"The Pitfall of Misinterpreting Reactive Problems as Transactional")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#what-tx"},"What are Transactional Data Problems?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#solve-tx"},"Solving Transactional Data Problems")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#what-rx"},"What are Reactive Data Problems?")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#solve-rx"},"Solving Reactive Data Problems")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#conclusion"},"Conclusion"))),(0,r.kt)("h2",{id:"pitfall"},"The Pitfall of Misinterpreting Reactive Problems as Transactional"),(0,r.kt)("img",{src:"/img/blog/arrived_logo.png",alt:"Arrived Logo >",width:"30%"}),(0,r.kt)("p",null,"Let's kick things off with an anecdote from my career. An episode where I mistakenly treated a reactive data problem as a transactional one, resulting in a full-blown application meltdown. Definitely not a shining moment of my career."),(0,r.kt)("p",null,'Flashback to 2011, I was the backend developer for a sprouting startup named "Arrived". Our vision was to connect people in the real world by using their phone\u2019s location data. That was the time when smartphones started to support geo-fencing and folks thought Foursquare was going to become the next Facebook. Fun times.'),(0,r.kt)("p",null,"We built an iPhone app that allowed users to establish geo-fences and automatically check-in, alerting their connections upon entry. For a brief overview of the app, check out ",(0,r.kt)("a",{parentName:"p",href:"https://techcrunch.com/2011/11/10/i-am-a-passenger-and-i-arrive-and-arrived/"},"this brutally hilarious review")," from our TechCrunch Disrupt final presentation. While it was soul-crushing at the time, it's quite a fun read in retrospect."),(0,r.kt)("p",null,"I implemented the backend of the application as a Java web service, complete with a REST API for user creation, user connection management, and alert dispatch. The API primarily dealt with storing and retrieving user states, connections, geo-fences, and more. These are typical transactional data problems: how to maintain your application state in a durable, reliable, and consistent way. To tackle this, I used MySQL as the database and an object-relational mapping library to translate my Java objects to database rows."),(0,r.kt)("p",null,'All was sailing smoothly until we decided to implement a social feature to enhance the onboarding experience and boost the app\'s "virality". This feature uploaded a user\u2019s phone contacts to check if any of their contacts were already using Arrived, suggesting them as potential connections.'),(0,r.kt)("img",{src:"/img/blog/arrived_app.png",alt:"Arrived Mobile App Screenshot >|",width:"30%"}),(0,r.kt)("p",null,"That looked like another transactional data problem to me. Or rather, I was oblivious to the existence of other types of data problems and defaulted to it being transactional."),(0,r.kt)("p",null,'Thus, I embarked on a path that would eventually lead to disaster. The "upload contacts" API call I set up did the following: '),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"stored all contact entries in the database, "),(0,r.kt)("li",{parentName:"ul"},"ran a for-loop to match any entry hashes already in the database, "),(0,r.kt)("li",{parentName:"ul"},'added a "potential connection" record to another table in case of a match.')),(0,r.kt)("p",null,"To my credit, the feature worked as intended. I even had a passing test case. But once we launched the feature in production, our database froze."),(0,r.kt)("p",null,"As it turned out, some users had an expansive social circle with over a thousand contacts. Running a transaction that writes thousands of records and fires off as many read queries on your primary operational database, which also services all your API requests, is a recipe for disaster. Needless to say, the database was not a fan of this idea and promptly crashed."),(0,r.kt)("p",null,"But my mistake was not a coding error. The code worked fine. The mistake was failing to realize that the \u201ccontacts matching feature\u201d was a reactive data problem, not a transactional one. We were ingesting data from an external source - a user\u2019s contact list - and reacting to it by comparing matches against our existing user base."),(0,r.kt)("p",null,"In the upcoming sections, we'll delve deeper into the differences between transactional and reactive data problems and how to solve them. We'll also revisit my reactive data problem and explore how a more informed approach could have saved me from a full-blown, hair-on-fire database crisis."),(0,r.kt)("p",null,"We will discuss how I could have solved my reactive data problem better and avoided a hair-on-fire database resurrection after we explore transactional and reactive data problems in more detail and how to distinguish between them."),(0,r.kt)("p",null,'As for "Arrived", we learned that our most active users were over-vigilant parents monitoring their children, which was not our target audience. Consequently, we had to close shop in less than two years.'),(0,r.kt)("h2",{id:"what-tx"},"What are Transactional Data Problems?"),(0,r.kt)("p",null,'Transactional data problems arise when you need to store and retrieve data concurrently while maintaining consistency. Here, "concurrently" refers to the simultaneous reading and writing of data by multiple threads or users. The trick is to ensure that data remains consistent throughout this flurry of updates.'),(0,r.kt)("p",null,'There are two forms of inconsistencies we need to avoid. The first relates to upholding application constraints. For instance, if a username is required to be unique, we cannot allow two user records with identical usernames. This would be inconsistent with our application\'s unique username constraint. We may have several such constraints, like "account balances can\'t be negative," or "each product id in the orders table must correspond to an existing row in the product table."'),(0,r.kt)("p",null,"The second inconsistency type relates to multiple updates triggered by a single request. We want to dodge situations where only some updates are stored. It's an all-or-nothing game - we either want all updates to be stored or none at all. For example, a request to transfer $100 from account A to account B requires updating both account balances. If only account A's balance is updated while account B's update fails, we've got a magical disappearing act of money."),(0,r.kt)("p",null,'Ensuring data consistency while managing concurrent user updates can be quite a challenge. You might encounter scenarios where two users try to register with the same username simultaneously or two users attempt to withdraw from the same account, causing the balance to plummet below zero. Situations like these are why data storage and retrieval often turn into a "problem" for developers.'),(0,r.kt)("p",null,"Transactional data problems typically surface when storing state for applications that multiple users can access concurrently, or when building CRUD APIs."),(0,r.kt)("h2",{id:"solve-tx"},"Solving Transactional Data Problems"),(0,r.kt)("p",null,"The panacea for transactional data problems? Databases. Developers harness the power of databases to efficiently handle the concurrency and consistency issues associated with transactional data problems."),(0,r.kt)("p",null,"However, databases aren't one-size-fits-all. They differ in the types of consistency and concurrency guarantees they offer. If you're using any of the popular relational databases (like Postgres, MySQL, SqlServer, Oracle, and Aurora), breathe easy. They're likely equipped with all the support you need. For other databases, it's worth checking what exactly they support to avoid surprises down the line."),(0,r.kt)("p",null,"Alongside the choice of database, you'll also want to equip yourself with a tool that simplifies interactions with the database from your programming language. Wrestling with databases directly can be cumbersome, requiring the use of drivers, query string writing, and data mapping. If you're working in an object-oriented programming language, an object-relational mapping layer (or ORM for short) can be your best friend, translating seamlessly between your application and the database. If not, seek out an SDK or database abstraction layer that's compatible with your chosen database."),(0,r.kt)("h2",{id:"what-rx"},"What are Reactive Data Problems?"),(0,r.kt)("p",null,"You have a Reactive data problem when your data source is outside your application or service's control, and you're required to respond to the data quickly. Let\u2019s break this down."),(0,r.kt)("h3",{id:"unconstrained-data"},"Unconstrained Data"),(0,r.kt)("p",null,"When the data originates from an external source or isn't subject to any application constraints, your application does not control the data source. External data sources could include other systems like logs, message queues, files, external databases, or applications. Here, the data pre-exists independently of your control. For instance, a user's contact list is an external data source."),(0,r.kt)("p",null,"Moreover, data could be uncontrolled even within your application, provided it's free of any constraints. This includes events that occur organically within your application, such as a user clicking a button or visiting a webpage. These events aren't within your direct control - they just happen."),(0,r.kt)("p",null,"This is a stark contrast to transactional data problems, where the key challenge lies in maintaining data consistency amidst concurrent updates."),(0,r.kt)("h3",{id:"the-need-for-speed"},"The Need for Speed"),(0,r.kt)("p",null,"Another characteristic of reactive data problems is the necessity for swift data processing and result generation. This quick reaction is twofold: it must occur shortly after receiving the data, and it involves computational processing of that data."),(0,r.kt)("p",null,"Take the contacts matching feature in Arrived, for instance. The goal was to encourage users to establish connections during the signup process. Consequently, we had to compute the matches within a few seconds - before the user completed the signup and exited the app."),(0,r.kt)("p",null,'How swift does this reaction need to be to qualify as "quick"? It varies according to your use case. Customer-facing use cases typically demand reactions within seconds to minutes, tops. For use cases like fraud detection, system automation, or financial transactions, you may need to respond within milliseconds. If the results can wait for hours or even days, it wouldn\'t qualify as quick.'),(0,r.kt)("p",null,'The "reaction" element primarily involves generating a response to incoming data, which could either serve back to the user or trigger an action. This could mean processing a user\'s shopping cart to suggest other products they might like, analyzing system metrics to detect potential overload, feeding user activity into a machine learning model for a personalized journey, or evaluating if a transaction request is fraudulent. In each instance, we take a piece of data, evaluate it within the application context, and produce a useful response.'),(0,r.kt)("p",null,"In essence, reactive data problems call for quick, efficient responses to one or multiple data sources. The challenges arise from the need to carry out data-intensive computations rapidly, efficiently, and robustly."),(0,r.kt)("p",null,"Reactive data problems commonly crop up in use cases such as:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Personalization or recommendation engines"),(0,r.kt)("li",{parentName:"ul"},"User experience features"),(0,r.kt)("li",{parentName:"ul"},"Metrics or time-series analysis"),(0,r.kt)("li",{parentName:"ul"},"Machine learning features"),(0,r.kt)("li",{parentName:"ul"},"Fraud detection"),(0,r.kt)("li",{parentName:"ul"},"Cybersecurity and intrusion detection")),(0,r.kt)("h2",{id:"solve-rx"},"How do you solve Reactive Data Problems?"),(0,r.kt)("p",null,"Let's circle back to the reactive data problem of the contacts matching feature. My initial solution involved splitting the transaction into several parts, moving some computation to a background thread, fine-tuning the database schema, and writing a hefty amount of SQL. This strategy was time-consuming, fragile, and a nightmare to maintain. A colleague shrugged it off with \u201cI\u2019ve no idea what\u2019s happening here, but I guess it works\u2026\u201d"),(0,r.kt)("p",null,"The problem? When all you have is a hammer, everything looks like a nail. So, I tried hammering that screw into the wall. As expected, it was neither pretty nor productive."),(0,r.kt)("img",{src:"/img/blog/reactive_data_layer_arrived.svg",alt:"A Reactive Data Layer Architecture >",width:"40%"}),(0,r.kt)("p",null,"To solve reactive data problems more effectively, we need to reimagine our data layer architecture. Let\u2019s give our database some company by introducing additional components that make it easier to process data reactively:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Queue"),": Introducing a persisted message queue (or log) into our architecture can ease asynchronous data processing. This robust, scalable tool allows you to write incoming data to the queue and process it when resources are available, significantly simplifying multi-step data processing."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Stream Processor"),": This is a framework dedicated to managing consecutive data processing steps, from data ingestion (reading data off the queue or from external systems) to data transformation, to writing the results to the database. This framework handles all task scheduling and execution, allowing you to focus on the actual processing logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Server"),": This component accepts incoming data, writes it to the queue, and serves the processed data from the database. Acting as the entry and exit point for the reactive data layer, the server brings everything together. You can integrate this functionality into an existing API server implementation or create a standalone server to isolate the reactive data use case into its own backend service.")),(0,r.kt)("p",null,"To improve the contact matching feature, we finally adopted a reactive data architecture as illustrated in the diagram above. Here's how the data flowed:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The server received the submitted contacts and wrote the entire data blob to a persisted messaging queue."),(0,r.kt)("li",{parentName:"ol"},"Three asynchronous tasks ran in the processing framework:",(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Splitter"),": This task read an entire contacts list from the queue, divided it into chunks of a maximum of 50 contacts, and wrote the resulting chunks back to the queue under a different topic."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Storer"),": This task read contact chunks from the queue and wrote the contact entries as individual records to the database."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("em",{parentName:"li"},"Matcher"),": This task read contact chunks, matched the contact entries against the user table, and wrote the found matches to the database."))),(0,r.kt)("li",{parentName:"ol"},"The database stored contact entries and contact matches in a separate logical database, isolated from the main operational database serving the CRUD API of the Arrived app."),(0,r.kt)("li",{parentName:"ol"},'The server responded to "recommended contacts" requests during the signup process by running a query against the database that combined all pre-computed matches for the user with matches from checking the user\'s phone number against previously stored contact entries.')),(0,r.kt)("p",null,"This solution was not only efficient and robust but also easier to maintain. Above all, it allowed us to concentrate on enhancing the feature instead of hacking around the database."),(0,r.kt)("p",null,"So, here's the key takeaway: instead of grappling with reactive data problems using a database alone, build a reactive data layer. It will save you considerable time and frustration."),(0,r.kt)("p",null,"If building a custom data layer seems intimidating, consider checking out DataSQRL. It's a tool that constructs reactive data layers for you. We've been developing DataSQRL to assist developers in resolving reactive data problems quickly and efficiently. We would love to hear your feedback!"),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type of Data Problem"),(0,r.kt)("th",{parentName:"tr",align:null},"Transactional"),(0,r.kt)("th",{parentName:"tr",align:null},"Reactive"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Response time expectation"),(0,r.kt)("td",{parentName:"tr",align:null},"Milliseconds"),(0,r.kt)("td",{parentName:"tr",align:null},"Milliseconds to minutes")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Main challenge"),(0,r.kt)("td",{parentName:"tr",align:null},"Consistency under concurrency"),(0,r.kt)("td",{parentName:"tr",align:null},"Quick Reactions")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Source of Data"),(0,r.kt)("td",{parentName:"tr",align:null},"Maintained by application"),(0,r.kt)("td",{parentName:"tr",align:null},"External or events")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Consistency Requirements"),(0,r.kt)("td",{parentName:"tr",align:null},"Data constraints & atomicity"),(0,r.kt)("td",{parentName:"tr",align:null},"Synchronization in time")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Data Layer Solution")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Database + ORM")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"td"},"Queue + Processor + Database + Server"))))),(0,r.kt)("p",null,"Transactional data problems arise when your application requires concurrent storage and retrieval of consistent data. On the other hand, reactive data problems occur when your application needs to quickly respond to data from external sources or events. Recognizing the distinction between these two types of data issues is crucial to implementing the most effective solution."),(0,r.kt)("p",null,"For transactional data problems, a data layer comprising a database and an Object-Relational Mapping (ORM) tool is often the best solution. On the contrary, reactive data problems are more efficiently addressed with a data layer that includes a queue, stream processor, database, and server. Understanding these distinctions and applying the appropriate solutions can significantly improve the efficiency and robustness of your data layer."))}p.isMDXComponent=!0}}]);