"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2318],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(a),h=r,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},1855:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},assets:function(){return p},toc:function(){return u},default:function(){return h}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],s={title:"SQRL"},l="What is SQRL?",d={unversionedId:"getting-started/concepts/sqrl",id:"getting-started/concepts/sqrl",title:"SQRL",description:"DataSQRL uses a declarative language called SQRL to express the logic and structure of a data service. You implement a data service in SQRL by defining how to combine, transform, and analyze the input data through a sequence of SQL(ish) statements. DataSQRL compiles SQRL scripts into fully-integrated data pipelines and an API layer that serves the result.",source:"@site/docs/getting-started/concepts/sqrl.md",sourceDirName:"getting-started/concepts",slug:"/getting-started/concepts/sqrl",permalink:"/docs/getting-started/concepts/sqrl",editUrl:"https://github.com/dataengai/dataengai.github.io/edit/main/docs/docs/getting-started/concepts/sqrl.md",tags:[],version:"current",frontMatter:{title:"SQRL"},sidebar:"docs",previous:{title:"DataSQRL",permalink:"/docs/getting-started/concepts/datasqrl"},next:{title:"Data Service",permalink:"/docs/getting-started/concepts/data-service"}},p={},u=[{value:"SQRL Features",id:"sqrl-features",level:2},{value:"Import Management",id:"import-management",level:3},{value:"Incremental Table Definition",id:"incremental-table-definition",level:3},{value:"Relationships",id:"relationships",level:3},{value:"Nested Tables",id:"nested-tables",level:3},{value:"Subscription",id:"subscription",level:3},{value:"Learn More",id:"learn-more",level:3},{value:"Why SQRL?",id:"why-sqrl",level:2}],c={toc:u};function h(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"what-is-sqrl"},"What is SQRL?"),(0,o.kt)("p",null,"DataSQRL uses a declarative language called SQRL to express the logic and structure of a data service. You implement a data service in SQRL by defining how to combine, transform, and analyze the input data through a sequence of SQL(ish) statements. DataSQRL compiles SQRL scripts into fully-integrated data pipelines and an API layer that serves the result."),(0,o.kt)("p",null,"SQRL is based on SQL. If you know how to read a ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT ... FROM ... WHERE")," query in SQL then you'll be able to read SQRL scripts with a few additional pointers. If you are unfamiliar with SQL, it's a good time to brush up on some SQL basics with our ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/sqrl/sql-primer"},"SQL primer"),"."),(0,o.kt)("p",null,"You express the logic of your data service in SQRL through a sequence SQL statements that define how to transform and analyze the input data to produce the result data that you want to expose as an API. The tables and relationships you create along the way define the structure of the resulting API which allows DataSQRL to generate the API and API schema for you and keep everything in sync. Tables are exposed as API endpoints with filters and orders and relationships can be traversed through the API by selecting related records."),(0,o.kt)("p",null,"SQRL is a loosely-typed language which infers data types from the input data. You can explicitly define data types and schemas if you want to, but in most cases you let DataSQRL handle all the type and schema management for you and save a lot of time."),(0,o.kt)("p",null,'SQRL stands for "Structured Query and Reaction Language" is designed specifically for developers who are building responsive data services. It has a low learning curve because it is essentially "just" SQL but adds enough convenience features to SQL to make it feel like a productive programming language. Check out the ',(0,o.kt)("a",{parentName:"p",href:"../nutshop-tutorial"},"introductory tutorial")," to get a feel for the language and see how SQRL allows you to build data services in a few minutes."),(0,o.kt)("h2",{id:"sqrl-features"},"SQRL Features"),(0,o.kt)("p",null,"SQRL adds a few constructs and some syntactic sugar on top of SQL to make it feel more like a development language and less like a game of Russian dolls with sub-queries. ",(0,o.kt)("br",null),"\nHere is a brief overview of how SQRL extends SQL:"),(0,o.kt)("h3",{id:"import-management"},"Import Management"),(0,o.kt)("p",null,"SQRL supports ",(0,o.kt)("inlineCode",{parentName:"p"},"IMPORT")," statements to declare the data dependencies of your SQRL script like you would software dependencies in a programming language."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"IMPORT nutshop-data.Orders;`\n")),(0,o.kt)("p",null,"This statement imports the ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table from the connected dataset ",(0,o.kt)("inlineCode",{parentName:"p"},"nutshop-data")," and makes it available in the script."),(0,o.kt)("h3",{id:"incremental-table-definition"},"Incremental Table Definition"),(0,o.kt)("p",null,"SQRL scripts are essentially a sequence of table and column definitions that allow you to incrementally build up the logic of your data service."),(0,o.kt)("p",null,"You can add columns to existing tables, like this ",(0,o.kt)("inlineCode",{parentName:"p"},"date")," column on our previously imported ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table which transforms a timestamp column to a ",(0,o.kt)("inlineCode",{parentName:"p"},"DateTime")," column:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Orders.date := function.time.fromEpochMillis(time);\n")),(0,o.kt)("p",null,"Or we can define a new ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," table based on the rows in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers := SELECT DISTINCT customerid AS id FROM Orders;\n")),(0,o.kt)("p",null,"SQRL uses the shorthand assignment operator ",(0,o.kt)("inlineCode",{parentName:"p"},":=")," to define the tables and column on the left-hand side of the assignment by the SQL statement on the right. This saves you from typing the more verbose ",(0,o.kt)("inlineCode",{parentName:"p"},"CREATE TABLE xyz AS ..."),". SQRL contains a few of those syntactic sugars to make development just a little bit more enjoyable. "),(0,o.kt)("p",null,"By defining tables and columns incrementally, you can write shorter, more comprehensible SQL statements that build on each other. This makes development with SQRL more like programming and SQRL scripts easy to read."),(0,o.kt)("h3",{id:"relationships"},"Relationships"),(0,o.kt)("p",null,"SQRL adds relationships to SQL so you can link tables to each other and explicitly label their relationship.\nRelationships are pre-defined ",(0,o.kt)("inlineCode",{parentName:"p"},"JOIN")," clauses that you can reuse across your script."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers.purchases := JOIN Orders ON Orders.customerid = _.id ORDER BY Orders.time DESC;\n")),(0,o.kt)("p",null,"We define the column ",(0,o.kt)("inlineCode",{parentName:"p"},"purchases")," on the table ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," to be a relationship to the ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table as defined by the ",(0,o.kt)("inlineCode",{parentName:"p"},"JOIN")," clause on the right. The ",(0,o.kt)("inlineCode",{parentName:"p"},"purchases")," relationship column links a record in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," table to all the records in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table that have a matching ",(0,o.kt)("inlineCode",{parentName:"p"},"customerid"),"."),(0,o.kt)("p",null,"Defining relationships makes SQRL scripts easier to read because the structure of the data is explicitly labeled. We can reference previously defined relationships in ",(0,o.kt)("inlineCode",{parentName:"p"},"FROM")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"JOIN")," clauses as well as expressions.  "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers.total_orders := SUM(purchases.total);\n")),(0,o.kt)("p",null,"Here, we define a new column ",(0,o.kt)("inlineCode",{parentName:"p"},"total_orders")," on the ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," table as the sum over the total values of all the orders a customer has placed. SQRL automatically expands relationship references to their full ",(0,o.kt)("inlineCode",{parentName:"p"},"JOIN"),". In this example, we are summing over ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders.total")," for all orders that match the ",(0,o.kt)("inlineCode",{parentName:"p"},"customerid")," of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," record. Note, that when you define new columns in this way, their definition is local to the parent table like a nested query in ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," clause."),(0,o.kt)("p",null,"Relationships get exposed in the API as well which allows users of the API to flexibly query the result data of your data service."),(0,o.kt)("h3",{id:"nested-tables"},"Nested Tables"),(0,o.kt)("p",null,"A lot of data these days is hierarchical which means it has a nested data structure. JSON is a prime example. SQRL adds support for hierarchical data by mapping it onto nested tables with parent-child relationships between them. This allows you to treat nested data just like normal tables."),(0,o.kt)("p",null,"For example, our imported ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," table comes from a connected stream of JSON order records that contain a nested array of items. Those items are mapped to the nested ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders.items")," table and link from an ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," record through the ",(0,o.kt)("inlineCode",{parentName:"p"},"items")," relationship."),(0,o.kt)("p",null,"We can treat the ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders.items")," table like any other and add a column to it that computes the total for each item:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Orders.items.total := quantity * unit_price - discount;\n")),(0,o.kt)("p",null,"We can then reference that newly defined column as we compute the total for an order:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Orders.total := sum(items.total);\n")),(0,o.kt)("p",null,"Treated hierarchical data as nested tables means that we don't need special data types or special access methods for nested data in SQRL. The DataSQRL compiler can figure out how to most efficiently represent such data. In our SQRL scripts we can focus on the logical representation and not worry about these optimization details."),(0,o.kt)("p",null,"In addition to supporting hierarchical input data, nested tables also allow us to define locally scoped tables:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers.past_purchases :=\n         SELECT i.productid, count(i.*) as num_orders, sum(i.quantity) as total_quantity\n         FROM _.purchases.items i\n         GROUP BY i.productid\n         ORDER BY num_orders DESC, total_quantity DESC;\n")),(0,o.kt)("p",null,"The table ",(0,o.kt)("inlineCode",{parentName:"p"},"past_purchases")," is defined as a nested table within ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers"),". The SQL query on the right-hand side is a ",(0,o.kt)("em",{parentName:"p"},"localized query")," which means it is evaluated in the context of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," table. We can think of the query definition as being applied to ",(0,o.kt)("em",{parentName:"p"},"each row")," of the parent table."),(0,o.kt)("p",null,"SQRL introduces the special table handle ",(0,o.kt)("inlineCode",{parentName:"p"},"_")," to refer to each row in the parent ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," table. The ",(0,o.kt)("inlineCode",{parentName:"p"},"FROM")," clause ",(0,o.kt)("inlineCode",{parentName:"p"},"_.purchases.items")," chains together the ",(0,o.kt)("inlineCode",{parentName:"p"},"purchases")," relationship on ",(0,o.kt)("inlineCode",{parentName:"p"},"Customers")," with the ",(0,o.kt)("inlineCode",{parentName:"p"},"items")," relationship on ",(0,o.kt)("inlineCode",{parentName:"p"},"Orders")," to retrieve all item records for all order records associated with a single customer record. Chaining together relationships allows us to avoid the complexity of multiple JOIN expressions in this query."),(0,o.kt)("h3",{id:"subscription"},"Subscription"),(0,o.kt)("p",null,'What makes DataSQRL "reactive" is that partially maintains the tables defined in SQRL and immediately updates partial results when new data comes in. That makes the API not only responsive to incoming requests but also to changes in the data.'),(0,o.kt)("p",null,"To respond more directly to changes in the data, SQRL introduces the concept of a ",(0,o.kt)("strong",{parentName:"p"},"subscription"),". A subscription observes a table and creates an event record for certain changes."),(0,o.kt)("p",null,"NewCustomerPromotion := SUBSCRIPTION ON ADD AS\nSELECT customerid, total_orders\nFROM Customers WHERE total_orders >= 100;"),(0,o.kt)("p",null,"This subscription observes a table that contains all the customer ids for customers who have spent more than a hundred dollars at our shop. The subscription triggers whenever a new record is added to the table (as defined by the ",(0,o.kt)("inlineCode",{parentName:"p"},"ON ADD"),") and produces an event record that is stored in the table ",(0,o.kt)("inlineCode",{parentName:"p"},"NewCustomerPromotion"),"."),(0,o.kt)("p",null,"You can build on subscription tables like other tables. You can only connect subscriptions to sinks which means that triggered event records get pushed to downstream consumers like queues or event buses that can process the event further or kick off a workflow."),(0,o.kt)("p",null,'In addition to the responsive API, subscriptions are the other element that makes SQRL "reactive" and allows you to build complex data services with little effort.'),(0,o.kt)("h3",{id:"learn-more"},"Learn More"),(0,o.kt)("p",null,"Take a look at the ",(0,o.kt)("a",{parentName:"p",href:"../nutshop-tutorial"},"introductory tutorial")," and the ",(0,o.kt)("a",{parentName:"p",href:"../intro/overview"},"DataSQRL training")," to see how these features work in practice while implementing a data service. ",(0,o.kt)("br",null),"\nFor a comprehensive and in-depth description of SQRL, check out the ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/sqrl/overview"},"reference documentation"),"."),(0,o.kt)("h2",{id:"why-sqrl"},"Why SQRL?"),(0,o.kt)("p",null,"Do we really need another language to build data services? We asked ourselves that question a lot. That's why we designed SQRL to be an upgrade to SQL rather than a new language. "),(0,o.kt)("p",null,"We think SQL is great. It is expressive and concise. It focuses on ",(0,o.kt)("em",{parentName:"p"},"what")," you need to do with the data and doesn't slow you down with the ",(0,o.kt)("em",{parentName:"p"},"how")," it should get done. And if you are working with data, you likely know SQL already or will have to learn it eventually."),(0,o.kt)("p",null,"But for software development, SQL is just a bit awkward. It was designed for expressing one-off queries, doesn't have a lot of constructs to build incrementally, and complex queries often end up looking pretty harrowing. Plus, it's a bit outdated and doesn't support popular concepts like relationships."),(0,o.kt)("p",null,"SQRL fixes that. It takes the good of SQL and adds some features that are missing or useful for developers implementing data services. But the extensions that SQRL adds are fully backwards compatible. In fact, you can take an SQRL script and compile it into vanilla SQL. That's essentially what the DataSQRL compiler does (plus some extra optimization). The result won't look pretty but it goes to show that there is nothing \"magical\" about SQRL. It's just a developer-focused upgrade to SQL."))}h.isMDXComponent=!0}}]);