"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8176],{5680:(e,t,n)=>{n.d(t,{xA:()=>u,yg:()=>m});var a=n(6540);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),p=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(o.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},g=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),g=r,m=c["".concat(o,".").concat(g)]||c[g]||d[g]||i;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=g;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[c]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9365:(e,t,n)=>{n.d(t,{A:()=>s});var a=n(6540),r=n(53);const i={tabItem:"tabItem_Ymn6"};function s(e){let{children:t,hidden:n,className:s}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.A)(i.tabItem,s),hidden:n},t)}},1470:(e,t,n)=>{n.d(t,{A:()=>v});var a=n(8168),r=n(6540),i=n(53),s=n(3104),l=n(6347),o=n(7485),p=n(1682),u=n(9466);function c(e){return function(e){return r.Children.map(e,(e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}function d(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??c(n);return function(e){const t=(0,p.X)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function g(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const a=(0,l.W6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,o.aZ)(i),(0,r.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(a.location.search);t.set(i,e),a.replace({...a.location,search:t.toString()})}),[i,a])]}function y(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,i=d(e),[s,l]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!g({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[o,p]=m({queryString:n,groupId:a}),[c,y]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,i]=(0,u.Dv)(n);return[a,(0,r.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:a}),h=(()=>{const e=o??c;return g({value:e,tabValues:i})?e:null})();(0,r.useLayoutEffect)((()=>{h&&l(h)}),[h]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!g({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),p(e),y(e)}),[p,y,i]),tabValues:i}}var h=n(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function b(e){let{className:t,block:n,selectedValue:l,selectValue:o,tabValues:p}=e;const u=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),d=e=>{const t=e.currentTarget,n=u.indexOf(t),a=p[n].value;a!==l&&(c(t),o(a))},g=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.A)("tabs",{"tabs--block":n},t)},p.map((e=>{let{value:t,label:n,attributes:s}=e;return r.createElement("li",(0,a.A)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>u.push(e),onKeyDown:g,onClick:d},s,{className:(0,i.A)("tabs__item",f.tabItem,s?.className,{"tabs__item--active":l===t})}),n??t)})))}function N(e){let{lazy:t,children:n,selectedValue:a}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return r.createElement("div",{className:"margin-top--md"},i.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a}))))}function T(e){const t=y(e);return r.createElement("div",{className:(0,i.A)("tabs-container",f.tabList)},r.createElement(b,(0,a.A)({},e,t)),r.createElement(N,(0,a.A)({},e,t)))}function v(e){const t=(0,h.A)();return r.createElement(T,(0,a.A)({key:String(t)},e))}},4217:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var a=n(8168),r=(n(6540),n(5680));n(1470),n(9365);const i={},s="SQRL Specification",l={unversionedId:"reference/sqrl/sqrl-spec",id:"reference/sqrl/sqrl-spec",title:"SQRL Specification",description:'This is the specification for SQRL, a declarative SQL query language developed at DataSQRL for describing data pipelines. SQRL stands for "Structured Query and Reaction Language" because it extends SQL with support for streaming data and the ability to react to data in realtime. In addition, SQRL adds a number of convenience features that make it development-friendly.',source:"@site/docs/reference/sqrl/sqrl-spec.md",sourceDirName:"reference/sqrl",slug:"/reference/sqrl/sqrl-spec",permalink:"/docs/reference/sqrl/sqrl-spec",draft:!1,editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/docs/reference/sqrl/sqrl-spec.md",tags:[],version:"current",frontMatter:{},sidebar:"docs",previous:{title:"DataSQRL",permalink:"/docs/reference/sqrl/learn"},next:{title:"SQRL Specification",permalink:"/docs/reference/sqrl/sqrl-spec"}},o={},p=[{value:"Table Type System",id:"table-type-system",level:2},{value:"Functions",id:"functions",level:2},{value:"Import",id:"import",level:2},{value:"Export",id:"export",level:2},{value:"Create Table",id:"create-table",level:2},{value:"Assignment operator",id:"assignment-operator",level:2},{value:"Distinct",id:"distinct",level:2},{value:"Queries",id:"queries",level:2},{value:"Nested Query",id:"nested-query",level:2},{value:"Join types",id:"join-types",level:4},{value:"Expressions",id:"expressions",level:2},{value:"Relationships",id:"relationships",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Table Paths",id:"table-paths",level:2},{value:"Comments",id:"comments",level:2},{value:"Hints",id:"hints",level:2}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.yg)(c,(0,a.A)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"sqrl-specification"},"SQRL Specification"),(0,r.yg)("p",null,"This is the specification for SQRL, a declarative SQL query language developed at DataSQRL for describing data pipelines. SQRL stands for ",(0,r.yg)("em",{parentName:"p"},'"',(0,r.yg)("strong",{parentName:"em"},"S"),"tructured ",(0,r.yg)("strong",{parentName:"em"},"Q"),"uery and ",(0,r.yg)("strong",{parentName:"em"},"R"),"eaction ",(0,r.yg)("strong",{parentName:"em"},"L"),'anguage"')," because it extends SQL with support for streaming data and the ability to react to data in realtime. In addition, SQRL adds a number of convenience features that make it development-friendly."),(0,r.yg)("h2",{id:"table-type-system"},"Table Type System"),(0,r.yg)("p",null,"In SQRL, every table is assigned a specific type that influences how queries interact with the data, the semantic validity of those queries, and how data is processed by different engines."),(0,r.yg)("p",null,"SQRL recognizes several distinct table types, each with unique characteristics and use cases:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"STREAM"),": Comprises a stream of immutable records, each identified by a synthetic primary key and timestamp. These tables are ideal for representing events or actions over time."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"VERSIONED_STATE"),": Contains records with a natural primary key and a timestamp, tracking changes over time to each record, thereby creating a change-stream."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"STATE"),": Similar to VERSIONED_STATE but without tracking the history of changes. Each record is uniquely identified by its natural primary key."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"LOOKUP"),": Supports lookup operations using a primary key but does not allow further processing of the data."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"RELATION"),": Represents relational data that lacks a primary key, timestamp, or explicit streaming semantics. It is used primarily for static relational data integration."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"STATIC"),": Consists of data that does not change over time, such as constants, table functions, or nested data structures. This type is treated as universally valid across all time points.")),(0,r.yg)("p",null,"These table types will be used throughout this specification to further describe the semantics of sql queries."),(0,r.yg)("h2",{id:"functions"},"Functions"),(0,r.yg)("p",null,"Functions in SQRL are designed to be engine-agnostic, ensuring that their implementation is consistent across different platforms and execution environments. This uniformity is crucial for maintaining the semantic integrity of functions when executed under various systems."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Characteristics of Functions")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Engine Agnosticism"),": Functions are defined in a way that does not depend on the specifics of the underlying engine."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Semantic Consistency"),": Regardless of the engine used, function should preserve their semantic meaning."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Mixed Engine Support"),": While functions are designed to be widely supported, some may have mixed support depending on the engine's capabilities."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Nullability Awareness"),": Functions in SQRL retain nullability information. This feature is vital for correct schema generation downstream, ensuring that data integrity is maintained through the potential propagation of null values."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Time-Preserving Capabilities"),": A significant feature of SQRL functions is their ability to handle time-based data efficiently. Time-preserving functions can manipulate and interpret timestamps in a way that aligns with the temporal dynamics of data streams.")),(0,r.yg)("p",null,"For example, a time-preserving function called 'endOfWeek' could be implemented to aggregate timestamps into time windows. Time windows are a means to divide time into discrete buckets and aggregate all stream records within each bucket to produce a new stream table that contains one row for each aggregate."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Users.spending := SELECT endOfWeek(p.time) AS week,\n         sum(t.price) AS spend, sum(t.saving) AS saved\n      FROM @.purchases p JOIN p.totals t\n      GROUP BY week ORDER BY week DESC;\n")),(0,r.yg)("h2",{id:"import"},"Import"),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"IMPORT qualifiedName (AS? alias=identifier)?")),(0,r.yg)("p",null,"An import in SQRL describes a ",(0,r.yg)("strong",{parentName:"p"},"table"),", ",(0,r.yg)("strong",{parentName:"p"},"function"),", or other ",(0,r.yg)("strong",{parentName:"p"},"sqrl script")," to be added to the schema. Import paths use the dot character ",(0,r.yg)("inlineCode",{parentName:"p"},".")," to separate path components."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"IMPORT datasqrl.seedshop.Orders;\n")),(0,r.yg)("p",null,"Imports are intended to act much like language dependencies. The SQRL specification does not describe how imports are resolved and is up to the implementation."),(0,r.yg)("p",null,"Imports can end with a ",(0,r.yg)("inlineCode",{parentName:"p"},"*")," to import all items on that level of the qualified path."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"IMPORT mypackage.*;\n")),(0,r.yg)("p",null,"Imports can be aliased using the ",(0,r.yg)("inlineCode",{parentName:"p"},"AS")," keyword. Imports that end with a ",(0,r.yg)("inlineCode",{parentName:"p"},"*")," cannot be aliased."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"IMPORT datasqrl.seedshop.Orders AS MyOrders;\n")),(0,r.yg)("h2",{id:"export"},"Export"),(0,r.yg)("p",null,(0,r.yg)("em",{parentName:"p"},"EXPORT table=tablePath TO sink=qualifiedName;")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"EXPORT")," statement is an explicit sink to a data system, like a kafka topic or database table. Import paths and export sink paths should be resolved the same way."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"EXPORT UserPromotion TO mysink.promotion;\n")),(0,r.yg)("p",null,"Export statements are most commonly used to export data to an external system, but it could refer to other components such as console log print statements or to a log engine. It is up to the underlying implementation to determine what modules are available by default for import and export paths. "),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"EXPORT UserPromotion TO print.promotion;\nEXPORT UserPromotion TO log.promotion;\n")),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"Exports do not describe the connector mapping when an optimizer splits the workload between multiple engines. ")),(0,r.yg)("h2",{id:"create-table"},"Create Table"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE MyTable(\n  myCol bigint,\n  myCol2 bigint\n);\n")),(0,r.yg)("p",null,"SQRL allows a 'create table' statement. Create table statements describe a table that the SQRL implementation provides storage for. The implementation can optionally bring additional fields, such as a primary key and timestamp."),(0,r.yg)("h2",{id:"assignment-operator"},"Assignment operator"),(0,r.yg)("p",null,"The assignment operator ",(0,r.yg)("inlineCode",{parentName:"p"},":=")," is used to specify the structure and contents of the right-hand side to the left-hand side. This operation is akin to the 'CREATE VIEW' statement in conventional SQL."),(0,r.yg)("h2",{id:"distinct"},"Distinct"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Products := DISTINCT Products ON id ORDER BY updated DESC;\n")),(0,r.yg)("p",null,"Distinct statements in SQRL are designed to select the most recent version of each row based on a specified key, effectively implementing deduplication in streaming data or ensuring data uniqueness in database systems."),(0,r.yg)("h2",{id:"queries"},"Queries"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"MyTable := SELECT * FROM Table;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Naming and Selecting Columns")),(0,r.yg)("p",null,"In SQRL, all columns must be explicitly named."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"// Invalid\nMyTable := SELECT COUNT() FROM Table;\n\n// Valid\nMyTable := SELECT COUNT() AS cnt FROM Table;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Table Shadowing")),(0,r.yg)("p",null,"Tables can be shadowed, meaning a new table can be created with the same name as an existing one."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"MyTable := SELECT * FROM MyTable;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Hidden Tables and Columns")),(0,r.yg)("p",null,"When the name of a table or column starts with the underscore character _, it is considered hidden. Hidden tables and columns are not exposed in the API or imported by other scripts."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"_MyHiddenTable := SELECT * FROM MyTable WHERE ...;\n")),(0,r.yg)("p",null,"Example of Hidden Column:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MyTable := SELECT id, _hiddenColumn FROM Table;\n")),(0,r.yg)("p",null,"In this example, _hiddenColumn will not be exposed in the API."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Usage of Hidden Tables")),(0,r.yg)("p",null,"Hidden tables are useful for intermediate calculations or data transformations that should not be accessible externally."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"_tempData := SELECT * FROM MyTable WHERE condition;\n")),(0,r.yg)("p",null,"In this example, _tempData is used for an internal operation and is not exposed."),(0,r.yg)("h2",{id:"nested-query"},"Nested Query"),(0,r.yg)("p",null,"Nested tables represent parent-child relationships and simplify aggregations by parent rows."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre"},"MyTable.query := SELECT * FROM x;\n")),(0,r.yg)("p",null,"We can query a nested table globally, i.e., over all rows in the table, or locally, i.e., only the rows associated with a given parent row."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Global Aggregation")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Order_totals := SELECT sum(total) as price, \n    sum(coalesce(discount, 0.0)) as saving FROM Orders.items;\n")),(0,r.yg)("p",null,"In this example, the Order_totals table contains a single aggregate that sums up the total and discount over all items in all orders. The result is one global aggregation over all order items."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Local Aggregation")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Orders.totals := SELECT sum(total) as price, \n    sum(coalesce(discount, 0.0)) as saving FROM @.items;\n")),(0,r.yg)("p",null,"This statement aggregates all items for each order. The result is one local aggregate for each row in the Orders table."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Difference Between Global and Local Aggregation")),(0,r.yg)("p",null,"The difference between the two statements lies in the FROM clause. The first statement references the Orders.items table globally, meaning it considers all rows in the Orders.items table without any specific parent context."),(0,r.yg)("p",null,'The second statement references the Orders.items table locally by accessing the items relationship column on Orders. This makes it a localized query, defining a new nested table totals under the Orders table. The query on the right-hand side of the statement is interpreted in the context of each row in the parent table. The at-sign @ is used to refer to the parent row in a localized query. Hence, @.items means "all items that are associated with the current order record through the items relationship".'),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Usage of Nested Table Definitions")),(0,r.yg)("p",null,"Nested table definitions are a convenient way to express GROUP BY and WINDOW queries by grouping on the rows in the parent table. This allows for more intuitive and organized data aggregation, making it easier to manage complex data relationships and calculations."),(0,r.yg)("h4",{id:"join-types"},"Join types"),(0,r.yg)("p",null,"SQRL provides additional join types outside of standard SQL:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Default join"),(0,r.yg)("li",{parentName:"ul"},"Temporal join"),(0,r.yg)("li",{parentName:"ul"},"Interval join")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Default Join")),(0,r.yg)("p",null,"A join without a qualifier is a default join. It is up to the implementation to decide the best join type given the conditions of the join."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"DefaultJoinExample := SELECT * FROM TableA JOIN TableB ON TableA.id = TableB.id;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Inner Join")),(0,r.yg)("p",null,"Inner joins are explicit inner joins. In stream processing contexts, this can mean maintaining the state on both sides of the join to allow proper semantics, which can be expensive."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"InnerJoinExample := SELECT * FROM TableA INNER JOIN TableB ON TableA.id = TableB.id;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Left Join and Left Outer Join")),(0,r.yg)("p",null,"In SQRL, a left join and a left outer join are distinct. Left joins can let the implementation decide the best join type. Left outer joins are explicit left joins."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"LeftJoinExample := SELECT * FROM TableA LEFT JOIN TableB ON TableA.id = TableB.id;\nLeftOuterJoinExample := SELECT * FROM TableA LEFT OUTER JOIN TableB ON TableA.id = TableB.id;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Temporal Join")),(0,r.yg)("p",null,"SQRL supports temporal joins between stream and state tables when joining on the state table's key. Temporal joins use the row from the state table at the timestamp of the stream row."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"TemporalJoinExample := \n  SELECT l.login_time, t.transaction_time, t.amount\n  FROM Logins l \n  TEMPORAL JOIN Transactions t \n  ON l.account_id = t.account_id;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Interval Join")),(0,r.yg)("p",null,"Interval joins are defined by specifying upper and lower time bounds. The INTERVAL JOIN condition specifies that a transaction must occur within a specified time frame after a login to be included in the join."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"CustomerActivity := \n  SELECT l.login_time, t.transaction_time, t.amount\n  FROM Logins l \n  INTERVAL JOIN Transactions t \n  ON l.account_id = t.account_id \n  AND t.transaction_time BETWEEN l.login_time AND l.login_time + INTERVAL '1' HOUR;\n")),(0,r.yg)("p",null,"This correlates logins with transactions that happen shortly after, capturing a critical timeframe for activity analysis."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Example: Temporal Joins in E-commerce")),(0,r.yg)("p",null,"Temporal joins are essential in SQRL as they define different semantics, joining stream tables with state tables. For example, in an e-commerce scenario, if the price changes on a product, you do not want to retroactively update already placed orders."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"IMPORT ecommerce.Orders;  // is a stream\nIMPORT ecommerce.Products;  // is a stream\n\nVersionedProducts := DISTINCT Product ON productid;  // converts to a versioned state table\n\nOrdersWithPrice := \n  SELECT * \n  FROM Orders\n  JOIN VersionedProducts;  // join on stream and state becomes a temporal join\n")),(0,r.yg)("p",null,"In this example, VersionedProducts becomes a versioned state table, and the join with Orders ensures that each order reflects the product price at the time of the order, not the current product price."),(0,r.yg)("h2",{id:"expressions"},"Expressions"),(0,r.yg)("p",null,"Expressions in SQRL allow you to define new columns based on calculations or transformations of existing columns."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Products.weight_in_oz := weight_in_gram / 28.35;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Defining New Columns")),(0,r.yg)("p",null,"This statement adds a new column weight_in_oz to the existing Products table, which converts the product weight to ounces. The column name is the last item in the table path."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Expression Constraints")),(0,r.yg)("p",null,"Expressions cannot be shadowed. Once an expression is defined, it cannot be overridden or redefined in the same context."),(0,r.yg)("p",null,"Once a table is queried, new columns cannot be added. Tables become immutable once referenced in a query."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Nested Expressions and Window Functions")),(0,r.yg)("p",null,"Nested expressions can evaluate window functions, allowing for calculations over a set of rows related to the current row."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"MyRow.num := RANK();\n")),(0,r.yg)("p",null,"In this example, MyRow.num is defined using the RANK() window function, which assigns a rank to each row within the partition of the dataset."),(0,r.yg)("h2",{id:"relationships"},"Relationships"),(0,r.yg)("p",null,"Relationships in SQRL make data relationships explicit, simplify joins, and allow API consumers to navigate through the data efficiently."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Defining Relationships")),(0,r.yg)("p",null,"A relationship is defined using a JOIN expression, interpreted for each row of the table on which the relationship is defined. The at-sign @ refers to each row."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Users.purchases := JOIN Orders ON Orders.customerid = @.id;\n")),(0,r.yg)("p",null,"This statement defines a purchases column in the Users table, relating each user to their corresponding orders where customerid matches the user's id."),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Benefits")),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Simplifies Joins"),": Avoids repetitive join statements."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("strong",{parentName:"li"},"Explicit Relationships"),": Makes data relationships clear and easy to follow")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Using Relationships in Queries")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Users.spending := \n  SELECT endOfWeek(p.time) AS week,\n         sum(t.price) AS spend, \n         sum(t.saving) AS saved\n  FROM @.purchases p \n  JOIN p.totals t\n  GROUP BY week \n  ORDER BY week DESC;\n")),(0,r.yg)("p",null,"This example defines a spending nested table under Users, aggregating order totals for all purchases of each user. The FROM @.purchases expands to FROM @ JOIN Orders p ON p.customerid = @.id."),(0,r.yg)("h2",{id:"parameters"},"Parameters"),(0,r.yg)("p",null,"Join declarations and tables in SQRL support parameters, allowing for dynamic queries."),(0,r.yg)("p",null,"Parameters use the SQL variable syntax, the ",(0,r.yg)("inlineCode",{parentName:"p"},"@")," followed by the variable name. This is not to be confused with localized queries"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"MyTable.byId(@val: BIGINT) := JOIN Table t ON t.id = @.id AND @val > 50;\nMyTableById(@id: STRING) := SELECT * FROM Table t WHERE t.id = @id;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Arguments")),(0,r.yg)("p",null,"Arguments may be provided in any syntactic order and maintain identical semantic meaning."),(0,r.yg)("p",null,"Parameterized queries are useful when describing different views of a table."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"ProductById(@ProductID: String) := \n  SELECT * FROM UniqueInventory \n  WHERE ProductID = @ProductID;\n")),(0,r.yg)("h2",{id:"table-paths"},"Table Paths"),(0,r.yg)("p",null,"In SQRL, table paths are traversed like a graph, not as subschemas."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"Users.spending := SELECT endOfWeek(p.time) AS week,\n         sum(t.price) AS spend, sum(t.saving) AS saved\n      FROM @.purchases p JOIN p.totals t\n      GROUP BY week ORDER BY week DESC;\n")),(0,r.yg)("p",null,"This statement defines a nested table ",(0,r.yg)("inlineCode",{parentName:"p"},"spending")," underneath ",(0,r.yg)("inlineCode",{parentName:"p"},"Users")," which aggregates over the nested order ",(0,r.yg)("inlineCode",{parentName:"p"},"totals")," for all purchases of each user. Relationships used in ",(0,r.yg)("inlineCode",{parentName:"p"},"FROM")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"JOIN")," are expanded to their original definition. That means, ",(0,r.yg)("inlineCode",{parentName:"p"},"FROM @.purchases")," gets expanded to ",(0,r.yg)("inlineCode",{parentName:"p"},"FROM @ JOIN Orders p ON p.customerid = @.id"),"."),(0,r.yg)("h2",{id:"comments"},"Comments"),(0,r.yg)("p",null,"SQRL supports the use of comments within the code to provide hints, enhance readability, provide documentation, and explain the logic of complex queries or operations."),(0,r.yg)("p",null,"SQRL supports two types of comments:"),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Single-line Comments"),": These are initiated with double forward slashes (//). Everything following the // on the same line is considered part of the comment."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"// This is a single-line comment explaining the next SQL command\nIMPORT data.SalesRecords;\n")),(0,r.yg)("p",null,(0,r.yg)("strong",{parentName:"p"},"Multi-line Comments"),": These are enclosed between /",(0,r.yg)("em",{parentName:"p"}," and "),"/. Everything within these markers is treated as a comment, regardless of the number of lines. T"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"/*\n * This is a multi-line comment.\n * It can span multiple lines and is often used to comment out\n * chunks of code or to provide detailed documentation.\n */\nIMPORT data.StockAdjustments;\n")),(0,r.yg)("h2",{id:"hints"},"Hints"),(0,r.yg)("p",null,"Hints are included within multi-line comments and are prefixed with a plus sign (+) followed by the hint type and optional parameters. These hints do not alter the SQL syntax but suggest how the underlying engine should treat the subsequent SQL commands. Hints are placed above assignment statements."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"// The below hint suggests that the following query should be executed on the stream engine.\n/* +exec(streams) */\nMyTable := SELECT * FROM InventoryStream;\n")))}d.isMDXComponent=!0}}]);