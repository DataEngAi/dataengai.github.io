"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1799],{3905:(e,t,r)=>{r.d(t,{Zo:()=>h,kt:()=>g});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),m=c(r),u=n,g=m["".concat(l,".").concat(u)]||m[u]||p[u]||o;return r?a.createElement(g,s(s({ref:t},h),{},{components:r})):a.createElement(g,s({ref:t},h))}));function g(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[m]="string"==typeof e?e:n,s[1]=i;for(var c=2;c<o;c++)s[c]=r[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},3034:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=r(7462),n=(r(7294),r(3905));const o={slug:"personalized-ai-search",title:"Personalized AI Search with Vector Embeddings for Semantic Profiles",authors:["matthias"],tags:["AI","Kafka","Flink","Postgres","search","personalization","DataSQRL"]},s=void 0,i={permalink:"/blog/personalized-ai-search",editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/blog/2023-11-20-personalized-ai-search.md",source:"@site/blog/2023-11-20-personalized-ai-search.md",title:"Personalized AI Search with Vector Embeddings for Semantic Profiles",description:"A common problem in search is ordering large result sets. Consider a user searching for \u201cjacket\u201d on an e-commerce platform. How do we order the large number of results to show the most relevant products first? In other words, what kind of jackets is the user looking for? Suit jackets, sport jackets, winter jackets?",date:"2023-11-20T00:00:00.000Z",formattedDate:"November 20, 2023",tags:[{label:"AI",permalink:"/blog/tags/ai"},{label:"Kafka",permalink:"/blog/tags/kafka"},{label:"Flink",permalink:"/blog/tags/flink"},{label:"Postgres",permalink:"/blog/tags/postgres"},{label:"search",permalink:"/blog/tags/search"},{label:"personalization",permalink:"/blog/tags/personalization"},{label:"DataSQRL",permalink:"/blog/tags/data-sqrl"}],readingTime:9.865,hasTruncateMarker:!0,authors:[{name:"Matthias Broecheler",title:"CEO of DataSQRL",url:"https://github.com/mbroecheler",imageURL:"/img/headshots/matthias1.png",key:"matthias"}],frontMatter:{slug:"personalized-ai-search",title:"Personalized AI Search with Vector Embeddings for Semantic Profiles",authors:["matthias"],tags:["AI","Kafka","Flink","Postgres","search","personalization","DataSQRL"]},nextItem:{title:"Personalized Recommendations for Current23 with Vector Embeddings in Flink and Kafka",permalink:"/blog/recommendations-current23"}},l={authorsImageUrls:[void 0]},c=[],h={toc:c},m="wrapper";function p(e){let{components:t,...r}=e;return(0,n.kt)(m,(0,a.Z)({},h,r,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("head",null,(0,n.kt)("meta",{property:"og:image",content:"/img/blog/ai_personalized_search_robot.png"}),(0,n.kt)("meta",{name:"twitter:image",content:"/img/blog/ai_personalized_search_robot.png"})),(0,n.kt)("p",null,"A common problem in search is ordering large result sets. Consider a user searching for \u201cjacket\u201d on an e-commerce platform. How do we order the large number of results to show the most relevant products first? In other words, what kind of jackets is the user looking for? Suit jackets, sport jackets, winter jackets?"),(0,n.kt)("p",null,"Often, we have the context to infer what kind of jacket a user is looking for based on their interactions on the site. For example, if a user has men\u2019s running shoes in their shopping cart, they are likely looking for men\u2019s sports jackets when they search for \u201cjacket\u201d."),(0,n.kt)("p",null,"At least to a human that seems pretty obvious. Yet, Amazon will return a somewhat random assortment of jackets in this scenario as shown in the screenshot below."),(0,n.kt)("img",{src:"/img/blog/ai_personalized_search_screenshot.png",alt:"Amazon search results for `jacket` |",width:"100%"}),(0,n.kt)("p",null,"To humans the semantic association between \u201crunning shoes\u201d and \u201csport jackets\u201d is natural, but for machines making such associations has been a challenge.\nWith recent advances in large-language models (LLMs) computers can now compute semantic similarities with high accuracy."),(0,n.kt)("p",null,"We are going to use LLMs to compute the semantic context of past user interactions via vector embeddings, aggregate them into a semantic profile, and then use the semantic profile to order search results by their semantic similarity to a user\u2019s profile."),(0,n.kt)("p",null,"In other words, we are going to rank search results by their semantic similarity to the things a user has been browsing. That gives us the context we are missing when the user enters a search query."),(0,n.kt)("p",null,"In this article, you will learn how to build a personalized shopping search with semantic vector embeddings step-by-step. You can apply the techniques in this article to any kind of search where a user can browse and search a collection of items: event search, knowledge bases, content search, etc."))}p.isMDXComponent=!0}}]);