"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8444],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=d(a),u=r,h=m["".concat(l,".").concat(u)]||m[u]||c[u]||i;return a?n.createElement(h,s(s({ref:t},p),{},{components:a})):n.createElement(h,s({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[m]="string"==typeof e?e:r,s[1]=o;for(var d=2;d<i;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},153:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const i={title:"Table"},s="SQRL Table",o={unversionedId:"reference/sqrl/table",id:"reference/sqrl/table",title:"Table",description:'The "table" is the central concept of SQRL. A table defines a set or stream of data. Every data record in SQRL is a row in a table. A table is defined by a list of columns which have unique column names.',source:"@site/docs/reference/sqrl/table.md",sourceDirName:"reference/sqrl",slug:"/reference/sqrl/table",permalink:"/docs/reference/sqrl/table",draft:!1,editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/docs/reference/sqrl/table.md",tags:[],version:"current",frontMatter:{title:"Table"},sidebar:"docs",previous:{title:"SQRL Documentation",permalink:"/docs/reference/sqrl/overview"},next:{title:"Relationship",permalink:"/docs/reference/sqrl/relationship"}},l={},d=[{value:"Table Definitions",id:"definition",level:2},{value:"Nested Tables",id:"nested",level:2},{value:"Localized Queries",id:"localized",level:3},{value:"State vs Stream Tables",id:"stateVsStream",level:2},{value:"SQL Compatibility",id:"sql-compatibility",level:2},{value:"Visibility",id:"visibility",level:2},{value:"Overwriting",id:"overwriting",level:3},{value:"Hiding",id:"hiding",level:3}],p={toc:d},m="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(m,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"sqrl-table"},"SQRL Table"),(0,r.kt)("p",null,'The "table" is the central concept of SQRL. A table defines a set or stream of data. Every data record in SQRL is a row in a table. A table is defined by a list of columns which have unique column names.'),(0,r.kt)("p",null,"A SQRL script defines a set of tables."),(0,r.kt)("h2",{id:"definition"},"Table Definitions"),(0,r.kt)("p",null,"A table is defined via ",(0,r.kt)("a",{parentName:"p",href:"../import"},"import")," statement at the beginning of a SQRL script or via a SQL query."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This documentation assumes that you are familiar with SQL and know how to write a ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT .. FROM .. WHERE .. GROUP BY")," query. If you want to refresh your SQL knowledge, take a look at the ",(0,r.kt)("a",{parentName:"p",href:"../sql-primer"},"SQL primer"),".")),(0,r.kt)("p",null,"Use the assignment operator ",(0,r.kt)("inlineCode",{parentName:"p"},":=")," to define the table on the left-hand of the assignment by the SQL query on the right-hand side. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Users := SELECT DISTINCT customerid AS id FROM Orders;\n")),(0,r.kt)("p",null,"This statement defines the table ",(0,r.kt)("inlineCode",{parentName:"p"},"Users")," by the SQL query that selects all distinct ",(0,r.kt)("inlineCode",{parentName:"p"},"customerid")," from the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," table.\nSQRL tables are usually defined by SQL queries over previously defined tables as in this example. You can use standard SQL syntax for the table queries. "),(0,r.kt)("p",null,"For the SQL nerds: SQRL tables are view definitions with a more developer-friendly syntax."),(0,r.kt)("p",null,"Tables can also be defined incrementally by adding column definitions to existing tables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Products.weight_in_oz := weight_in_gram / 28.35;\n")),(0,r.kt)("p",null,"This statement adds a new column ",(0,r.kt)("inlineCode",{parentName:"p"},"weight_in_oz")," to the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," table which converts the product weight to ounces."),(0,r.kt)("h2",{id:"nested"},"Nested Tables"),(0,r.kt)("p",null,"SQRL supports nested tables through table paths to represent nested or hierarchical data. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," data stream from the ",(0,r.kt)("a",{parentName:"p",href:"../../../getting-started/quickstart"},"Quickstart Seedshop example")," has nested ",(0,r.kt)("inlineCode",{parentName:"p"},"items")," for each item in an order. Such nested data maps onto nested tables in SQRL. ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders.items")," is the table path that accesses the nested ",(0,r.kt)("inlineCode",{parentName:"p"},"items")," data for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," example."),(0,r.kt)("p",null,"We can use and query nested tables like any other table in SQRL."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Orders.items.total := quantity * unit_price - discount?0.0;\n")),(0,r.kt)("p",null,"This statement adds a new ",(0,r.kt)("inlineCode",{parentName:"p"},"total")," column to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders.items")," table that computes the total price for each item."),(0,r.kt)("p",null,"Nested tables are special in that each row in a nested table is associated with exactly one ",(0,r.kt)("em",{parentName:"p"},"parent")," row in the parent table. The parent row can be accessed through the ",(0,r.kt)("inlineCode",{parentName:"p"},"parent")," ",(0,r.kt)("a",{parentName:"p",href:"../relationship"},"relationship column")," that is implicitly defined for all nested tables. Likewise, all child rows of a parent row can be accessed through a relationship column on the parent row of the same name as the nested table."),(0,r.kt)("h3",{id:"localized"},"Localized Queries"),(0,r.kt)("p",null,"When querying nested tables we need to be mindful to query the nested table at the right scope. We can query a nested table globally, i.e. over all rows in the table, or locally, i.e. only the rows associated with a given parent row."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Order_totals := SELECT sum(total) as price, \n    sum(discount?0.0) as saving FROM Orders.items;\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders_totals")," table contains a single aggregate that sums up the total and discout over ",(0,r.kt)("strong",{parentName:"p"},"all")," items in ",(0,r.kt)("strong",{parentName:"p"},"all")," orders. The result is one global aggregation over all order items."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Orders.totals := SELECT sum(total) as price, \n    sum(discount?0.0) as saving FROM @.items;\n")),(0,r.kt)("p",null,"This statement, on the other hand, aggregates ",(0,r.kt)("strong",{parentName:"p"},"all")," items ",(0,r.kt)("strong",{parentName:"p"},"for each")," order. The result is one local aggregate for each row in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," table."),(0,r.kt)("p",null,"The difference between the two statements is in the ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM")," clause. The first statement references the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders.items")," table globally. The second statement references the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders.items")," table locally by accessing the ",(0,r.kt)("inlineCode",{parentName:"p"},"items")," relationship column on ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders"),"."),(0,r.kt)("p",null,"The second statement is a ",(0,r.kt)("strong",{parentName:"p"},"localized query")," because it defines a new nested table ",(0,r.kt)("inlineCode",{parentName:"p"},"totals")," under the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," table on the left-hand side of the statement. That means the query on the right-hand side of the statement is interpreted in the context of ",(0,r.kt)("em",{parentName:"p"},"each")," row in the parent table. The at-sign ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," is used to refer to the parent row in a localized query. Hence, ",(0,r.kt)("inlineCode",{parentName:"p"},"@.items"),' means "all items that are associated with the current order record through the ',(0,r.kt)("inlineCode",{parentName:"p"},"items"),' relationship".'),(0,r.kt)("p",null,"Nested table definitions can query arbitrary tables. The only difference to non-nested tables is that the query is interpreted in the local context of the parent table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Users.order_stats := SELECT max(o.time) as most_recent, count(1) as num\n      FROM @ JOIN Orders o ON o.customerid = @.id;\n")),(0,r.kt)("p",null,"This statement defines the nested table ",(0,r.kt)("inlineCode",{parentName:"p"},"order_stats")," underneath ",(0,r.kt)("inlineCode",{parentName:"p"},"Users")," as an aggregation for a users most recent and total number of orders. In this example, we are explicitly selecting from ",(0,r.kt)("inlineCode",{parentName:"p"},"@")," to reference the parent row in this localized query. ",(0,r.kt)("inlineCode",{parentName:"p"},"FROM @ JOIN Orders o ON o.customerid = @.id"),' means "select the current parent row and join with all orders where the ',(0,r.kt)("inlineCode",{parentName:"p"},"customerid")," is equal to the ",(0,r.kt)("inlineCode",{parentName:"p"},"id"),' of the parent row".'),(0,r.kt)("p",null,"For the SQL nerds: Nested table definitions are a convenient way to express ",(0,r.kt)("inlineCode",{parentName:"p"},"GROUP BY")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"WINDOW")," queries by grouping on the rows in the parent table."),(0,r.kt)("h2",{id:"stateVsStream"},"State vs Stream Tables"),(0,r.kt)("p",null,"SQRL distinguishes between ",(0,r.kt)("em",{parentName:"p"},"state")," and ",(0,r.kt)("em",{parentName:"p"},"stream")," tables. State tables hold records that change over time as records are modified. Stream tables hold immutable records that have a timestamp and are naturally ordered in time."),(0,r.kt)("p",null,'State tables have the standard set semantics of SQL. A row in a state table is uniquely identified by a key (i.e. one or multiple key columns) and the column values of that row can change over time as the record is modified. Rows in state tables represent entities, objects, or anything that can be identified independent of time. You define and treat state tables as "normal" SQL tables.'),(0,r.kt)("p",null,"Stream tables contain immutable rows of data that map onto a timeline. Rows in stream tables represent events or things that occur at a point in time. A row in a stream table has an explicit or implicit timestamp that anchors the record at a certain point in time. The notion of time, how timestamps are attached to stream records, and how time is handled is important to stream tables. SQRL uses slightly different semantics when querying stream tables to account for time. You can read more about ",(0,r.kt)("a",{parentName:"p",href:"../stream"},"stream tables")," and how SQRL handles ",(0,r.kt)("a",{parentName:"p",href:"../time"},"time"),"."),(0,r.kt)("p",null,"State and stream tables are like two sides of the same coin by giving you different views of your data. A state table represents the data as it currently is whereas a stream table represents data over time. Each state table has an underlying change stream and stream tables can be transformed to state through aggregation or deduplication. Those transformations are covered in the ",(0,r.kt)("a",{parentName:"p",href:"../stream"},"stream tables")," documentation."),(0,r.kt)("h2",{id:"sql-compatibility"},"SQL Compatibility"),(0,r.kt)("p",null,"SQRL tables are defined as SQL queries over previously defined or imported tables."),(0,r.kt)("p",null,"SQRL supports the standardized syntax and semantics of SQL and adds some convenience features like ",(0,r.kt)("a",{parentName:"p",href:"../relationship"},"relationships")," and ",(0,r.kt)("a",{parentName:"p",href:"#nested"},"nested tables"),"."),(0,r.kt)("p",null,"SQRL differs from SQL in the following ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Aggregations, default joins, and unions have a different semantics for ",(0,r.kt)("a",{parentName:"li",href:"../stream"},"stream tables"),"."),(0,r.kt)("li",{parentName:"ul"},"SQRL does not use LEFT joins. Use ",(0,r.kt)("a",{parentName:"li",href:"../relationship#expressions"},"relationship expressions")," instead."),(0,r.kt)("li",{parentName:"ul"},"SQRL does not use WINDOWs. Use ",(0,r.kt)("a",{parentName:"li",href:"#nested"},"nested tables")," instead."),(0,r.kt)("li",{parentName:"ul"},"UNION between state tables require that the tables have the same key columns. UNION between different types of tables is not supported."),(0,r.kt)("li",{parentName:"ul"},"SQRL has restricted support for sub-queries and encourages developers to use ",(0,r.kt)("a",{parentName:"li",href:"../relationship#expressions"},"relationship expressions")," or break sub-queries out into separate intermediate tables instead. "),(0,r.kt)("li",{parentName:"ul"},"SQRL does not support OUTER, ANTI, or SEMI joins.")),(0,r.kt)("p",null,"Most of the differences to SQL serve the purpose to make SQRL easier to use and understand. In addition, there are some temporary limitations of SQL syntax that SQRL does not yet support. See the ",(0,r.kt)("a",{parentName:"p",href:"../../../dev/roadmap"},"roadmap")," to learn more."),(0,r.kt)("h2",{id:"visibility"},"Visibility"),(0,r.kt)("h3",{id:"overwriting"},"Overwriting"),(0,r.kt)("p",null,"You can overwrite existing tables and columns in SQRL with newer definitions. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Products := DISTINCT Products ON id ORDER BY updated DESC;\n")),(0,r.kt)("p",null,"This statement redefines the ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," table by de-duplicating the imported ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," changelog stream on the ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," column. The original ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," stream table still exists but is no longer referencable in the SQRL script. All references to ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," are now resolved to the de-duplicated state table."),(0,r.kt)("p",null,"Similarly, we can overwrite columns on tables:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"Users.country := country?'none';\n")),(0,r.kt)("p",null,"This statement cleans up ",(0,r.kt)("inlineCode",{parentName:"p"},"Users")," data by replacing the ",(0,r.kt)("inlineCode",{parentName:"p"},"country")," column with a new column definition that replaces ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," values with string literal ",(0,r.kt)("inlineCode",{parentName:"p"},"none"),"."),(0,r.kt)("h3",{id:"hiding"},"Hiding"),(0,r.kt)("p",null,"When the name of a table or column starts with the underscore character  ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," the table or column is hidden. Hidden tables and columns are not exposed in the API or imported by other scripts. "),(0,r.kt)("p",null,"Hidden tables and columns are used to define intermediate state that is local to the current script and not accessible from outside of that script."))}c.isMDXComponent=!0}}]);