"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1630],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),m=r,h=d["".concat(l,".").concat(m)]||d[m]||p[m]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,i[1]=s;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},6219:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const o={title:"Advanced Concepts"},i="Advanced Concepts in DataSQRL",s={unversionedId:"getting-started/intro/advanced",id:"getting-started/intro/advanced",title:"Advanced Concepts",description:"You have made it through the entire introduction tutorial and want to keep learning about DataSQLR? Kudos to you! This page highlights some advanced aspects of DataSQRL with pointers to more information, so you can continue your journey to ninja SQRL status \ud83e\udd47.",source:"@site/docs/getting-started/intro/advanced.md",sourceDirName:"getting-started/intro",slug:"/getting-started/intro/advanced",permalink:"/docs/getting-started/intro/advanced",draft:!1,editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/docs/docs/getting-started/intro/advanced.md",tags:[],version:"current",frontMatter:{title:"Advanced Concepts"},sidebar:"docs",previous:{title:"Design the API",permalink:"/docs/getting-started/intro/api"},next:{title:"What is DataSQRL?",permalink:"/docs/getting-started/concepts/datasqrl"}},l={},u=[{value:"Subscriptions",id:"subscriptions",level:2},{value:"SQRL Functions",id:"sqrl-functions",level:2},{value:"Relationship Expressions",id:"relationship-expressions",level:2},{value:"Table Schema",id:"table-schema",level:2},{value:"Hidden Fields and Utility Functions",id:"hidden-fields-and-utility-functions",level:2},{value:"Hints and Optimization",id:"hints",level:2},{value:"Next Steps",id:"next-steps",level:2}],c={toc:u},d="wrapper";function p(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"advanced-concepts-in-datasqrl"},"Advanced Concepts in DataSQRL"),(0,r.kt)("p",null,"You have made it through the entire introduction tutorial and want to keep learning about DataSQLR? Kudos to you! This page highlights some advanced aspects of DataSQRL with pointers to more information, so you can continue your journey to ninja SQRL status \ud83e\udd47."),(0,r.kt)("h2",{id:"subscriptions"},"Subscriptions"),(0,r.kt)("p",null,"In a ",(0,r.kt)("a",{parentName:"p",href:"data-sources"},"previous chapter")," we talked a great deal about importing data sources as stream tables. You can also export stream tables to external data sinks."),(0,r.kt)("p",null,"The last feature we want to implement in our customer 360 is a trigger or\nnotification when a customer has more than $100 in purchases so that we can\nemail them with a special coupon to reward their loyalty."),(0,r.kt)("p",null,"SQRL supports subscriptions which observe an underlying table and trigger\nevents."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"NewCustomerPromotion := SUBSCRIPTION ON ADD AS\n      SELECT customerid, total_orders \n      FROM Customers WHERE total_orders >= 100;\n")),(0,r.kt)("p",null,"We define the subscription ",(0,r.kt)("inlineCode",{parentName:"p"},"NewCustomerPromotion")," which observes the table\ndefined by the ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," query for all customers with more than $100 in total\npurchases. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ON ADD")," qualifier for this subscription means that an event\nis triggered whenever a new row is added to that table."),(0,r.kt)("p",null,"A subscription defines an event table that contains a row for every\nevent that is triggered by the underlying table. We can treat it like any other\ntable, for example, by defining a relationship to ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"NewCustomerPromotion.customer := JOIN Customers ON Customers.id = @.customerid;\n")),(0,r.kt)("p",null,"However, subscriptions are special in that they are exposed as WebSockets in the\nAPI that proactively sent out events when they occur to subscribing users. In\naddition, we can register queues with DataSQRL server where subscription events\nget posted to notify downstream systems. We are going to look into\nboth of those subscription access methods in more detail in the ",(0,r.kt)("a",{parentName:"p",href:"api"},"next section"),"."),(0,r.kt)("p",null,"Subscriptions are a powerful feature to ",(0,r.kt)("em",{parentName:"p"},"react")," to changes in the data and\nnotify downstream systems or consumers of the API immediately."),(0,r.kt)("h2",{id:"sqrl-functions"},"SQRL Functions"),(0,r.kt)("p",null,"we are going to start with good-ol' boring functions. Functions are incredibly useful, can make your script more concise, and your life a lot easier."),(0,r.kt)("p",null,"We used the function ",(0,r.kt)("inlineCode",{parentName:"p"},"function.time.fromEpochMillis")," in the ",(0,r.kt)("a",{parentName:"p",href:"../quickstart"},"nut shop tutorial")," and referenced the function by its fully qualified name. If you use a function repeatedly, you can import it to save you from typing the full name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"IMPORT nutshop-data.Products;\nIMPORT nutshop-data.Orders;\n\nIMPORT function.time.fromEpochMillis;\n\nOrders.date := fromEpochMillis(time);\n")),(0,r.kt)("p",null,"You can also import all functions in a particular package:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"IMPORT function.time.*;\n")),(0,r.kt)("p",null,"Note, that the imported functions are placed in the same namespace as the imported tables and datasets, so you have to be careful that those names do not overlap. If they do, you can rename functions or tables on import."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"IMPORT function.time.fromEpochMillis AS epoch2Millis;\n\nOrders.date := epoch2Millis(time);\n")),(0,r.kt)("p",null,"As a side note, ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," is a reserved keyword in SQRL and you cannot name your datasets or tables ",(0,r.kt)("inlineCode",{parentName:"p"},"function")," to avoid confusion."),(0,r.kt)("p",null,"SQRL includes a lot of useful functions. You can view the ",(0,r.kt)("a",{parentName:"p",href:"/docs/category/functions"},"complete listing of function packages"),". Here are some highlights:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"iff")," is an inline if-then-else function that evaluates the boolean expression given as the first argument and returns the second argument if it is true, otherwise it returns the third argument. Great for small conditionals where ",(0,r.kt)("em",{parentName:"li"},"case-when")," statements are overkill."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"coalesce")," returns the second argument if the first argument is null. Great for normalizing messy data."),(0,r.kt)("li",{parentName:"ul"},"If you are doing string transformations, take a look at the ",(0,r.kt)("a",{parentName:"li",href:"/docs/reference/sqrl/functions/string"},"string function package"),"."),(0,r.kt)("li",{parentName:"ul"},"Working with timestamps, dates, and all matters of time gets a lot easier with the ",(0,r.kt)("a",{parentName:"li",href:"/docs/reference/sqrl/functions/time"},"time function package"),"."),(0,r.kt)("li",{parentName:"ul"},"geo, statistics")),(0,r.kt)("h2",{id:"relationship-expressions"},"Relationship Expressions"),(0,r.kt)("p",null,"We can also access relationships when we define tables or columns in our\nSQRL script:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customer.total_orders := SUM(purchases.total);\n")),(0,r.kt)("p",null,"In this incremental column definition from the nut shop tutorial, we are summing\nthe total value of all orders related to a particular customer record by the\n",(0,r.kt)("inlineCode",{parentName:"p"},"purchases")," relationship."),(0,r.kt)("p",null,"This expression is much easier to read and write than the equivalent\ndefinition:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers.total_orders := SELECT SUM(o.total) FROM Orders o WHERE o.customerid = @.id;\n")),(0,r.kt)("p",null,"And we can reuse relationships across definitions. For instance, we can rewrite\nthe definition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"since")," column on ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers")," as:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"Customers.since := MIN(purchases.date);\n")),(0,r.kt)("h2",{id:"table-schema"},"Table Schema"),(0,r.kt)("p",null,"If you peak into the ",(0,r.kt)("inlineCode",{parentName:"p"},"mySourcePackage")," folder you'll see two files in there for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers")," table: ",(0,r.kt)("inlineCode",{parentName:"p"},"customers.table.json")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"customers.schema.yml"),". The former file is the data source configuration DataSQRL uses to connect to the data. The latter specifies the schema of the data."),(0,r.kt)("p",null,"Luckily, DataSQRL's ",(0,r.kt)("inlineCode",{parentName:"p"},"discover")," command generates both files for us. You don't"),(0,r.kt)("p",null,"The data type of columns is inferred from the input data or definition of the table.\nIn our example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"time")," column on the ",(0,r.kt)("inlineCode",{parentName:"p"},"Orders")," table is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"Number")," which\nDataSQRL inferred from the records in the orders data. The data type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"date")," column\ndefined above is ",(0,r.kt)("inlineCode",{parentName:"p"},"DateTime")," which is inferred from the result type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"fromEpochMillis"),"\nfunction."),(0,r.kt)("p",null,"In most cases, type inference is obvious and you can let DataSQRL handle data types and schema for you.\nOne less thing to worry about. \\\nRead more about ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/sources/schema"},"schema management"),"\nand how to ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/sources/schema"},"manually define data types")," for\ndatasets with heterogeneous or very messy data where it isn't obvious."),(0,r.kt)("h2",{id:"hidden-fields-and-utility-functions"},"Hidden Fields and Utility Functions"),(0,r.kt)("p",null,"DataSQRL automatically adds a few hidden columns to all records from imported data source tables:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"_uuid"),": A unique identifier for the record assigned by the DataSQRL server on ingest."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"_ingest_time"),": A timestamp that marks the time when the record was ingested by DataSQRL server."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"_source_time"),": The timestamp attached to the record by the data source. This timestamp is only available if the data source supports it and null otherwise.")),(0,r.kt)("p",null,"The unique identifier is useful to distinguish records and track data lineage."),(0,r.kt)("p",null,"The timestamps are often used when we transform a change-record event table into an entity table as discussed in ",(0,r.kt)("a",{parentName:"p",href:"sqrl#event-entity%7D"},"the previous section")," on entity and event tables. For example, we used ",(0,r.kt)("inlineCode",{parentName:"p"},"_ingest_time")," in the entity table definition of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," table:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"Products := DISTINCT Products ON id ORDER BY _ingest_time DESC;\n")),(0,r.kt)("p",null,"This statement defines ",(0,r.kt)("inlineCode",{parentName:"p"},"Products")," entity records as the last change event for each product id ordered by the time the events were ingested. We can also define ",(0,r.kt)("em",{parentName:"p"},"last")," in terms of the source time of an event record:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"Products := DISTINCT Products ON id ORDER BY _source_time DESC;\n")),(0,r.kt)("p",null,"In practice, the definitions lead to the same result unless records from the data source may arrive out of order when they are ingested by DataSQRL. In that case, it is better to use ",(0,r.kt)("inlineCode",{parentName:"p"},"_source_time")," if the data source supports it."),(0,r.kt)("p",null,"To assign unique ids and timestamps to the event tables we define via subscriptions, we can use the utility functions ",(0,r.kt)("inlineCode",{parentName:"p"},"uuid()")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"now()")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"SELECT")," clause of the subscription:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"NewCustomerPromotion := SUBSCRIPTION ON ADD AS\nSELECT uuid() AS event_id, now() AS event_time, customerid, total_orders\nFROM Customers WHERE total_orders >= 100;\n")),(0,r.kt)("h2",{id:"hints"},"Hints and Optimization"),(0,r.kt)("p",null,"You can control how DataSQRL executes your scripts by providing annotation hints."),(0,r.kt)("p",null,"Before we talk about those hints, let's take a short detour to discuss how DataSQRL executes SQRL scripts. DataSQRL is a combination of a stream processing engine and a database. The stream processing engine ingests data from the connected sources, validates it, and updates the tables defined in the SQRL script that are affected by the new data record. Table records are eventually written to the database where they can be queried by the API to answer API requests."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"(insert schematic diagram visualizing it)")),(0,r.kt)("p",null,"When DataSQRL converts an SQRL script to an execution plan, the optimizer determines which tables and columns should be incrementally computed by the stream processing engine when new data arrives or computed upon request inside the database for each API query. This decision has important implications for the performance and cost of the data service."),(0,r.kt)("p",null,"For example, the column ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers._recent_avg_protein")," from our ",(0,r.kt)("inlineCode",{parentName:"p"},"customer360.sqrl")," script would be very expensive to compute at query time when we request product recommendations from the API because it requires a multi-way ",(0,r.kt)("inlineCode",{parentName:"p"},"JOIN")," starting from all orders that a customer placed in the last 6 month. If we computed this at query time, the database would have to fetch a lot of data which takes time and is costly. It is much cheaper to incrementally update this column value whenever the customer places a new order and store the result in the database so it is instantly available at query time. \\\nOn the other hand, incrementally computing the ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers.products_by_protein")," table when data changes would be very expensive since the ordering changes anytime the ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers._recent_avg_protein")," changes with a new order for that customer. Since we only have a couple hundred product records that don't change very often, it is much more efficient to compute ",(0,r.kt)("inlineCode",{parentName:"p"},"Customers.products_by_protein")," at query time."),(0,r.kt)("p",null,"DataSQRL collects statistics on the source data and analyzes your script to make the optimal decision on whether to incrementally compute a particular table and column or compute it at query time. However, sometimes the optimizer gets it wrong. When that happens, you can provide a hint to DataSQRL to dictate that decision to the optimizer."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Please send us example SQRL scripts where the optimizer makes the wrong decision and produces suboptimal results. We are actively working on improving the optimizer and your input is super valuable to us.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sqrl"},"-- @optimizer(materialize=true)\nCustomers._recent_avg_protein :=\n        SELECT SUM(e.quantity * p.weight_in_gram * n.protein)/SUM(e.quantity * p.weight_in_gram)\n        FROM @.purchases.items e JOIN e.product p JOIN p.nutrition n\n        WHERE e.parent.date > now() - INTERVAL 6 MONTH;\n\n-- @api(paginate=true)\n-- @optimizer(materialize=false)\nCustomers.products_by_protein :=\n        SELECT p.id AS productid, ABS(p.nutrition.protein - @._recent_avg_protein) AS protein_difference FROM Products p\n        ORDER BY protein_difference ASC LIMIT 20;\nCustomers.products_by_protein.product := JOIN Products ON Products.id = _productid LIMIT 1;\n")),(0,r.kt)("p",null,"With the ",(0,r.kt)("inlineCode",{parentName:"p"},"@optimizer")," annotation we can pass hints to the optimizer. The boolean flag ",(0,r.kt)("inlineCode",{parentName:"p"},"materialize")," tells the optimizer whether to incrementally update a table with changing data - i.e. to materialize a table as database folks would say - or to compute the table results at query time with each API request."),(0,r.kt)("p",null,"Learn more about the ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/operations/optimizer"},"DataSQRL optimizer")," and how to provide hints to control the execution plan that it generates for your SQRL script. You can also learn more about the ",(0,r.kt)("a",{parentName:"p",href:"/docs/dev/architecture"},"architecture of DataSQRL")," to dive deep into the internals of the system."),(0,r.kt)("h2",{id:"next-steps"},"Next Steps"),(0,r.kt)("p",null,"Congratulations, you not only finished the introduction tutorial but also completed the extra credit. What a champ! You are definitely ready to get started with DataSQRL."),(0,r.kt)("p",null,"For additional information, you can consult the ",(0,r.kt)("a",{parentName:"p",href:"/docs/reference/overview"},"reference documentation")," which covers all the details and then some. \\"),(0,r.kt)("p",null,"Want to learn more about the internals of DataSQRL or contribute to the codebase? The ",(0,r.kt)("a",{parentName:"p",href:"/docs/dev/overview"},"developer documentation")," provides a detailed breakdown of the DataSQRL architecture and everything you need to know to extend DataSQRL yourself."))}p.isMDXComponent=!0}}]);