"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[549],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),p=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=p(e.components);return n.createElement(c.Provider,{value:t},e.children)},l="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),l=p(r),d=a,h=l["".concat(c,".").concat(d)]||l[d]||m[d]||o;return r?n.createElement(h,i(i({ref:t},u),{},{components:r})):n.createElement(h,i({ref:t},u))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[l]="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=r[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},3882:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const o={},i=void 0,s={permalink:"/blog/ideas/optimizer",editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/blog/blog/ideas/optimizer.md",source:"@site/blog/ideas/optimizer.md",title:"ideas/optimizer",description:"You can control how DataSQRL executes your scripts by providing annotation hints.",date:"2023-03-02T17:21:50.000Z",formattedDate:"March 2, 2023",tags:[],readingTime:2.79,hasTruncateMarker:!1,authors:[],frontMatter:{},nextItem:{title:"introducing-sqrl",permalink:"/blog/2023/02/02/introducing-sqrl"}},c={authorsImageUrls:[]},p=[],u={toc:p},l="wrapper";function m(e){let{components:t,...r}=e;return(0,a.kt)(l,(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"You can control how DataSQRL executes your scripts by providing annotation hints."),(0,a.kt)("p",null,"Before we talk about those hints, let's take a short detour to discuss how DataSQRL executes SQRL scripts. DataSQRL is a combination of a stream processing engine and a database. The stream processing engine ingests data from the connected sources, validates it, and updates the tables defined in the SQRL script that are affected by the new data record. Table records are eventually written to the database where they can be queried by the API to answer API requests."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"(insert schematic diagram visualizing it)")),(0,a.kt)("p",null,"When DataSQRL converts an SQRL script to an execution plan, the optimizer determines which tables and columns should be incrementally computed by the stream processing engine when new data arrives or computed upon request inside the database for each API query. This decision has important implications for the performance and cost of the data service."),(0,a.kt)("p",null,"For example, the column ",(0,a.kt)("inlineCode",{parentName:"p"},"Customers._recent_avg_protein")," from our ",(0,a.kt)("inlineCode",{parentName:"p"},"customer360.sqrl")," script would be very expensive to compute at query time when we request product recommendations from the API because it requires a multi-way ",(0,a.kt)("inlineCode",{parentName:"p"},"JOIN")," starting from all orders that a customer placed in the last 6 month. If we computed this at query time, the database would have to fetch a lot of data which takes time and is costly. It is much cheaper to incrementally update this column value whenever the customer places a new order and store the result in the database so it is instantly available at query time. \\\nOn the other hand, incrementally computing the ",(0,a.kt)("inlineCode",{parentName:"p"},"Customers.products_by_protein")," table when data changes would be very expensive since the ordering changes anytime the ",(0,a.kt)("inlineCode",{parentName:"p"},"Customers._recent_avg_protein")," changes with a new order for that customer. Since we only have a couple hundred product records that don't change very often, it is much more efficient to compute ",(0,a.kt)("inlineCode",{parentName:"p"},"Customers.products_by_protein")," at query time."),(0,a.kt)("p",null,"DataSQRL collects statistics on the source data and analyzes your script to make the optimal decision on whether to incrementally compute a particular table and column or compute it at query time. However, sometimes the optimizer gets it wrong. When that happens, you can provide a hint to DataSQRL to dictate that decision to the optimizer."),(0,a.kt)("admonition",{type:"caution"},(0,a.kt)("p",{parentName:"admonition"},"Please send us example SQRL scripts where the optimizer makes the wrong decision and produces suboptimal results. We are actively working on improving the optimizer and your input is super valuable to us.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sqrl"},"-- @optimizer(materialize=true)\nCustomers._recent_avg_protein :=\n        SELECT SUM(e.quantity * p.weight_in_gram * n.protein)/SUM(e.quantity * p.weight_in_gram)\n        FROM @.purchases.items e JOIN e.product p JOIN p.nutrition n\n        WHERE e.parent.date > now() - INTERVAL 6 MONTH;\n\n-- @api(paginate=true)\n-- @optimizer(materialize=false)\nCustomers.products_by_protein :=\n        SELECT p.id AS productid, ABS(p.nutrition.protein - @._recent_avg_protein) AS protein_difference FROM Products p\n        ORDER BY protein_difference ASC LIMIT 20;\nCustomers.products_by_protein.product := JOIN Products ON Products.id = _productid LIMIT 1;\n")),(0,a.kt)("p",null,"With the ",(0,a.kt)("inlineCode",{parentName:"p"},"@optimizer")," annotation we can pass hints to the optimizer. The boolean flag ",(0,a.kt)("inlineCode",{parentName:"p"},"materialize")," tells the optimizer whether to incrementally update a table with changing data - i.e. to materialize a table as database folks would say - or to compute the table results at query time with each API request."),(0,a.kt)("p",null,"Learn more about the ",(0,a.kt)("a",{parentName:"p",href:"/docs/reference/operations/optimizer"},"DataSQRL optimizer")," and how to provide hints to control the execution plan that it generates for your SQRL script. You can also learn more about the ",(0,a.kt)("a",{parentName:"p",href:"/docs/dev/architecture"},"architecture of DataSQRL")," to dive deep into the internals of the system."))}m.isMDXComponent=!0}}]);