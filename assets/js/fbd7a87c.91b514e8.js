"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4192],{5788:(e,t,n)=>{n.d(t,{Iu:()=>u,yg:()=>c});var a=n(1504);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=r,c=d["".concat(l,".").concat(m)]||d[m]||g[m]||i;return n?a.createElement(c,o(o({ref:t},u),{},{components:n})):a.createElement(c,o({ref:t},u))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1191:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(5072),r=(n(1504),n(5788));const i={title:"Quickstart Tutorial"},o="DataSQRL Quickstart in 10 Minutes",s={unversionedId:"getting-started/quickstart",id:"getting-started/quickstart",title:"Quickstart Tutorial",description:'|" width="35%"/>',source:"@site/docs/getting-started/quickstart.md",sourceDirName:"getting-started",slug:"/getting-started/quickstart",permalink:"/docs/getting-started/quickstart",draft:!1,editUrl:"https://github.com/DataSQRL/datasqrl.github.io/edit/main/docs/getting-started/quickstart.md",tags:[],version:"current",frontMatter:{title:"Quickstart Tutorial"},sidebar:"docs",previous:{title:"Getting Started with DataSQRL",permalink:"/docs/getting-started/overview"},next:{title:"DataSQRL Tutorial",permalink:"/docs/getting-started/intro/overview"}},l={},p=[{value:"Create Script",id:"create-script",level:2},{value:"Run Script",id:"run",level:2},{value:"Query API",id:"query",level:2},{value:"Customize API",id:"customize-api",level:2},{value:"Ingest Metrics with Mutations",id:"ingest-metrics-with-mutations",level:2},{value:"Realtime Updates with Subscriptions",id:"subscription",level:2},{value:"Next Steps",id:"next",level:2}],u={toc:p},d="wrapper";function g(e){let{components:t,...n}=e;return(0,r.yg)(d,(0,a.c)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"datasqrl-quickstart-in-10-minutes"},"DataSQRL Quickstart in 10 Minutes"),(0,r.yg)("img",{src:"/img/getting-started/squirrel_computer.jpeg",alt:"Metrics Monitoring Quickstart >|",width:"35%"}),(0,r.yg)("p",null,"We are going to build a data product that analyzes sensor metrics in 10 minutes. Tik tok, let's go!"),(0,r.yg)("h2",{id:"create-script"},"Create Script"),(0,r.yg)("p",null,"First, we are going to define the metrics processing for our data product using SQL."),(0,r.yg)("admonition",{type:"info"},(0,r.yg)("p",{parentName:"admonition"},"If you are unfamiliar with SQL, we recommend you read our ",(0,r.yg)("a",{parentName:"p",href:"/docs/reference/sqrl/sql-primer"},"SQL Primer")," first.")),(0,r.yg)("p",null,"In the terminal or command line, create an empty folder for the SQL script:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"> mkdir metrics; cd metrics\n")),(0,r.yg)("p",null,"Then create a new file called ",(0,r.yg)("inlineCode",{parentName:"p"},"metrics.sqrl")," and copy-paste the following SQL code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql",metastring:"title=metrics.sqrl",title:"metrics.sqrl"},"IMPORT datasqrl.example.sensors.SensorReading; -- Import metrics\nIMPORT time.endOfSecond;  -- Import time function\n/* Aggregate sensor readings to second */\nSecReading := SELECT sensorid, endOfSecond(time) as timeSec,\n                     avg(temperature) as temp \n              FROM SensorReading GROUP BY sensorid, timeSec;\n/* Get max temperature in last minute per sensor */\nSensorMaxTemp := SELECT sensorid, max(temp) as maxTemp\n                 FROM SecReading\n                 WHERE timeSec >= now() - INTERVAL 1 MINUTE\n                 GROUP BY sensorid;\n")),(0,r.yg)("p",null,'DataSQRL\'s flavor of SQL is called "SQRL", which defines tables using the ',(0,r.yg)("inlineCode",{parentName:"p"},":=")," assignment operator and supports explicit data and function imports."),(0,r.yg)("p",null,"In the script, we import the sensor data we are processing and a time function we use for aggregation."),(0,r.yg)("p",null,"We define the ",(0,r.yg)("inlineCode",{parentName:"p"},"SecReading")," table that aggregates all sensor metrics within one second to smooth our temperature readings.\nWe define another table ",(0,r.yg)("inlineCode",{parentName:"p"},"SensorMaxTemp")," which computes the maximum temperature in the last minute for each sensor."),(0,r.yg)("h2",{id:"run"},"Run Script"),(0,r.yg)("p",null,"DataSQRL compiles our SQRL script into an integrated data pipeline and runs the pipeline with the following command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"docker run -it -p 8888:8888 -p 8081:8081 -v $PWD:/build datasqrl/cmd run metrics.sqrl\n")),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"To run this command you need to have ",(0,r.yg)("a",{parentName:"p",href:"https://docs.docker.com/get-docker/"},"Docker")," installed on your machine and running. The first time you run this command takes an eternity to download. Make sure you are using docker-compose V2.")),(0,r.yg)("admonition",{type:"note"},(0,r.yg)("p",{parentName:"admonition"},"If you are using Powershell on Windows, you need to replace ",(0,r.yg)("inlineCode",{parentName:"p"},"$PWD")," with ",(0,r.yg)("inlineCode",{parentName:"p"},"${PWD}")," to reference your local directory in the docker command.")),(0,r.yg)("p",null,"Once the pipeline is running, it will ingest, process, store, and serve the data through an API."),(0,r.yg)("h2",{id:"query"},"Query API"),(0,r.yg)("p",null,"Open your favorite browser and navigate to ",(0,r.yg)("a",{parentName:"p",href:"http://localhost:8888//graphiql/"},(0,r.yg)("inlineCode",{parentName:"a"},"http://localhost:8888//graphiql/"))," to access GraphiQL - a popular GraphQL IDE. Write GraphQL queries in the left-hand panel. For example, copy the following query:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql"},"{\n  SensorMaxTemp (sensorid: 1) {\n    maxTemp\n  }\n}\n")),(0,r.yg)("p",null,'When you hit the "run" button you get the maximum temperature for the sensor with id ',(0,r.yg)("inlineCode",{parentName:"p"},"1")," in the last minute."),(0,r.yg)("p",null,"And there you have it: a running data pipeline that ingests metrics, aggregates them, and exposes the results through a GraphQL API which you can call in your applications."),(0,r.yg)("p",null,"To stop the pipeline, interrupt it with ",(0,r.yg)("inlineCode",{parentName:"p"},"CTRL-C"),"."),(0,r.yg)("h2",{id:"customize-api"},"Customize API"),(0,r.yg)("p",null,"Got a little more time? Let's customize the GraphQL API and add a metrics ingestion endpoint."),(0,r.yg)("p",null,"By default, DataSQRL generates a GraphQL schema for us based on the tables we define in the SQRL script. That's great for rapid prototyping, but eventually we want to customize the API and limit data access."),(0,r.yg)("p",null,"To save us time, we are going to start with the GraphQL API that DataSQRL generates for us by running this command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"docker run --rm -v $PWD:/build datasqrl/cmd compile metrics.sqrl -a graphql\n")),(0,r.yg)("p",null,"There is now a file called ",(0,r.yg)("inlineCode",{parentName:"p"},"schema.graphqls")," in the same folder as our script. Rename it to ",(0,r.yg)("inlineCode",{parentName:"p"},"metricsapi.graphqls")," and take a look.\nNotice, how each table defined in our SQRL script maps to a query endpoint in the API and an associated result type. The query endpoints accept arguments for each column of the table to filter the results by column values."),(0,r.yg)("p",null,"We are going to remove most of those arguments to only support querying by ",(0,r.yg)("inlineCode",{parentName:"p"},"sensorid"),". We will also remove the ",(0,r.yg)("inlineCode",{parentName:"p"},"SensorReading")," query endpoint and result type to only expose the smoothed-out sensor readings from the ",(0,r.yg)("inlineCode",{parentName:"p"},"SecReading")," table."),(0,r.yg)("p",null,"In the ",(0,r.yg)("inlineCode",{parentName:"p"},"metricsapi.graphqls")," file, remove the ",(0,r.yg)("inlineCode",{parentName:"p"},"SensorReading")," type and replace the query definition with the following:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql",metastring:"title=metricsapi.graphqls",title:"metricsapi.graphqls"},"type Query {\n  SecReading(sensorid: Int!): [SecReading!]\n  SensorMaxTemp(sensorid: Int): [SensorMaxTemp!]\n}\n")),(0,r.yg)("p",null,"Note, that we made ",(0,r.yg)("inlineCode",{parentName:"p"},"sensorid")," a required argument for the ",(0,r.yg)("inlineCode",{parentName:"p"},"SecReading")," query endpoint."),(0,r.yg)("p",null,"Now, invoke the compiler with the GraphQL schema we just created and launch the updated pipeline:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"docker run -it -p 8888:8888 -p 8081:8081 -v $PWD:/build datasqrl/cmd run metrics.sqrl metricsapi.graphqls;\n")),(0,r.yg)("p",null,"When you refresh GraphiQL in the browser, you see that the API is simpler and only exposes the data for our use case."),(0,r.yg)("h2",{id:"ingest-metrics-with-mutations"},"Ingest Metrics with Mutations"),(0,r.yg)("p",null,"So far, we have ingested metrics data from an external source imported from the ",(0,r.yg)("a",{parentName:"p",href:"http://dev.datasqrl.com"},"DataSQRL repository"),". The data source is static which is convenient for whipping up an example data product, but we want our data pipeline to provide a metrics ingestion endpoint."),(0,r.yg)("p",null,"No problem, let's add it to our GraphQL schema by appending the following mutation to the ",(0,r.yg)("inlineCode",{parentName:"p"},"metricsapi.graphqls")," file we created above"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql",metastring:"title=metricsapi.graphqls",title:"metricsapi.graphqls"},"type Mutation {\n  AddReading(metric: SensorReading!): CreatedReading\n}\n\ninput SensorReading {\n  sensorid: Int!\n  temperature: Float!\n}\n\ntype CreatedReading {\n  _source_time: String!\n  sensorid: Int!\n}\n")),(0,r.yg)("p",null,"To use the data created by this mutation in our SQRL script, we have to import it. Replace the first two lines of the ",(0,r.yg)("inlineCode",{parentName:"p"},"metrics.sqrl")," script with:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql",metastring:"title=metrics.sqrl",title:"metrics.sqrl"},"IMPORT metricsapi.AddReading AS SensorReading;\nIMPORT time.endOfSecond;\nSensorReading.time := _source_time;\n")),(0,r.yg)("p",null,"We are now using data ingested through the API mutation endpoint instead of the static example data. And for the timestamp on the metrics, we are using the special column ",(0,r.yg)("inlineCode",{parentName:"p"},"_source_time")," which captures the time data was ingested through the API."),(0,r.yg)("p",null,"Terminate the running service, run the compiler again, and re-launch the pipeline. In GraphiQL, run the following mutation to add a temperature reading:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql"},"mutation addReading {\n  AddReading(metric: {\n    sensorid: 1,\n    temperature: 37.2\n  }) {\n    sensorid\n    _source_time\n  }\n}\n")),(0,r.yg)("p",null,"Hit the run button a few times and change the temperature and/or sensor id to insert multiple readings."),(0,r.yg)("p",null,"To query the maximum temperatures, run the following query:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql"},"{\n  SensorMaxTemp {\n    sensorid\n    maxTemp\n  }\n}\n")),(0,r.yg)("h2",{id:"subscription"},"Realtime Updates with Subscriptions"),(0,r.yg)("p",null,"DataSQRL supports GraphQL subscription, so we can push processed data to the user in realtime instead of the user having to query for it. This is useful when we want to update dashboards with new metrics automatically and in realtime."),(0,r.yg)("p",null,"Let's add an alert when the temperature of a sensor exceeds 50\xb0. First, we add the ",(0,r.yg)("inlineCode",{parentName:"p"},"HighTempAlert")," table to our script:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql",metastring:"title=metrics.sqrl",title:"metrics.sqrl"},"HighTempAlert := SELECT * FROM SecReading WHERE temp > 50;\n")),(0,r.yg)("p",null,"Open the ",(0,r.yg)("inlineCode",{parentName:"p"},"metricsapi.graphqls")," file and add the following subscription and type:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-graphql",metastring:"title=metricsapi.graphqls",title:"metricsapi.graphqls"},"type Subscription {\n    HighTempAlert(sensorid: Int): HighTempAlert\n}\n\ntype HighTempAlert {\n    sensorid: Int!\n    timeSec: String!\n    temp: Float!\n}\n")),(0,r.yg)("p",null,"This allows users of our API to subscribe to the ",(0,r.yg)("inlineCode",{parentName:"p"},"HighTempAlert")," table with an optional ",(0,r.yg)("inlineCode",{parentName:"p"},"sensorid")," argument to only receive alerts for a particular sensor. Whenever a sensor reading exceeds 50\xb0, the user will be immediately notified."),(0,r.yg)("p",null,"Compile and run the updated pipeline with the command above (make sure you have terminated and shut down the running one first) and once everything is fired up again, open ",(0,r.yg)("a",{parentName:"p",href:"/metrics-subscription-demo"},"this webpage")," to see the subscription work in practice:\nAfter you run the ",(0,r.yg)("inlineCode",{parentName:"p"},"addReading")," mutation in GraphiQL (make sure the temperature is > 50\xb0), you should see the alert appear on the webpage."),(0,r.yg)("p",null,"Voila, we just built a fully-functioning monitoring service that ingests, aggregates, and serves metrics data in realtime with push-based alerts. And the best part? The DataSQRL compiler ensures that it is efficient, fast, robust, and scalable."),(0,r.yg)("h2",{id:"next"},"Next Steps"),(0,r.yg)("p",null,"DataSQRL provides a number of features that make it easy, fast, and efficient to build data pipelines and event-driven microservices. Read the ",(0,r.yg)("a",{parentName:"p",href:"../intro/overview"},"DataSQRL tutorial")," to learn about all the features while building a Customer 360\xb0 application and recommendation engine. It'll be fun!"))}g.isMDXComponent=!0}}]);