---
title: "Design"
---

# Design GraphQL APIs

The easiest way to design your custom GraphQL data API with DataSQRL is to start with the GraphQL schema that is generated by the compiler.

```bash
docker run -v $PWD:/build datasqrl/datasqrl-cmd compile myscript.sqrl -a graphql
```

When you add the `-a graphql` option, the compiler writes a `schema.graphqls` GraphQL schema file to the local directory where the compiler was invoked.

:::danger
Change the name of the GraphQL schema file before you customize it. That way you avoid accidentally overwriting your changes if you run the command with the `-a` option again.
:::

The compiler generates *complete* GraphQL schemas, which means that the schema contains all tables, fields, and relationships defined in the SQRL script as well as field filters for all fields. You can create your own custom GraphQL schema by trimming the generated schema and only expose those tables, fields, relationships, and filters that are required by your data API.

## Script to GraphQL Schema Mapping

DataSQRL maps the tables, fields, and relationships defined in the SQRL script to a GraphQL schema which exposes the data through a GraphQL API.

Tables are mapped to types in the GraphQL schema and table columns map to fields of that type. The field data type is the same as the column data type from the table. If the type isn't available in GraphQL, it is serialized into a generic type like `string`.

Relationship columns of a table map to fields of the type associated with the table. The type of that field is the type associated with the table that the relationship links to.

The mapping between tables and types and (relationship) columns and fields is established by case-insensitive name. That means, to expose the table `Orders` in the API we have to create a type `Orders` or `orders` in the GraphQL schema.

Non-nested table in the script can also map onto query entry-points of the same name as the table which can be used to query the table.

Query fields and relationship fields accept arguments of the returned type which map onto equality predicate filters.

## Example GraphQL Schema

The following is a GraphQL schema for the [Quickstart tutorial](../../../getting-started/quickstart).

```graphqls
type Query {
  Orders(time: String): [Orders!]
  Users(id: Int!): Users
}

type Users {
  id: Int!
  purchases: [Orders!]
  spending(week: String): [spending!]
}

type spending {
  week: String!
  spend: Float!
  saved: Float!
}

type Orders {
  id: Int!
  customerid: Int!
  time: String!
  items: [items!]
  totals: totals
}

type items {
  productid: Int!
  quantity: Int!
  unit_price: Float!
  discount: Float
  total: Float!
}

type totals {
  price: Float!
  saving: Float!
}
```